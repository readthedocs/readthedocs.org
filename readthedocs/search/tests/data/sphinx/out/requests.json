{
  "path": "",
  "title": "",
  "sections": [
    {
      "id": "",
      "title": "",
      "content": "Developer Interface This part of the documentation covers all the interfaces of Requests. For parts where Requests depends on external libraries, we document the most important right here and provide links to the canonical documentation. Main Interface All of Requests\u2019 functionality can be accessed by these 7 methods. They all return an instance of the Response object. requests.request(method, url, **kwargs)[source] Constructs and sends a Request. Parameters method \u2013 method for the new Request object: GET, OPTIONS, HEAD, POST, PUT, PATCH, or DELETE. url \u2013 URL for the new Request object. params \u2013 (optional) Dictionary, list of tuples or bytes to send in the query string for the Request. data \u2013 (optional) Dictionary, list of tuples, bytes, or file-like object to send in the body of the Request. json \u2013 (optional) A JSON serializable Python object to send in the body of the Request. headers \u2013 (optional) Dictionary of HTTP Headers to send with the Request. cookies \u2013 (optional) Dict or CookieJar object to send with the Request. files \u2013 (optional) Dictionary of 'name': file-like-objects (or {'name': file-tuple}) for multipart encoding upload. file-tuple can be a 2-tuple ('filename', fileobj), 3-tuple ('filename', fileobj, 'content_type') or a 4-tuple ('filename', fileobj, 'content_type', custom_headers), where 'content-type' is a string defining the content type of the given file and custom_headers a dict-like object containing additional headers to add for the file. auth \u2013 (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth. timeout (float or tuple) \u2013 (optional) How many seconds to wait for the server to send data before giving up, as a float, or a (connect timeout, read timeout) tuple. allow_redirects (bool) \u2013 (optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection. Defaults to True. proxies \u2013 (optional) Dictionary mapping protocol to the URL of the proxy. verify \u2013 (optional) Either a boolean, in which case it controls whether we verify the server\u2019s TLS certificate, or a string, in which case it must be a path to a CA bundle to use. Defaults to True. stream \u2013 (optional) if False, the response content will be immediately downloaded. cert \u2013 (optional) if String, path to ssl client cert file (.pem). If Tuple, (\u2018cert\u2019, \u2018key\u2019) pair. Returns Response object Return type requests.Response Usage: >>> import requests >>> req = requests.request('GET', 'https://httpbin.org/get') >>> req <Response [200]> requests.head(url, **kwargs)[source] Sends a HEAD request. Parameters url \u2013 URL for the new Request object. **kwargs \u2013 Optional arguments that request takes. If allow_redirects is not provided, it will be set to False (as opposed to the default request behavior). Returns Response object Return type requests.Response requests.get(url, params=None, **kwargs)[source] Sends a GET request. Parameters url \u2013 URL for the new Request object. params \u2013 (optional) Dictionary, list of tuples or bytes to send in the query string for the Request. **kwargs \u2013 Optional arguments that request takes. Returns Response object Return type requests.Response requests.post(url, data=None, json=None, **kwargs)[source] Sends a POST request. Parameters url \u2013 URL for the new Request object. data \u2013 (optional) Dictionary, list of tuples, bytes, or file-like object to send in the body of the Request. json \u2013 (optional) A JSON serializable Python object to send in the body of the Request. **kwargs \u2013 Optional arguments that request takes. Returns Response object Return type requests.Response requests.put(url, data=None, **kwargs)[source] Sends a PUT request. Parameters url \u2013 URL for the new Request object. data \u2013 (optional) Dictionary, list of tuples, bytes, or file-like object to send in the body of the Request. json \u2013 (optional) A JSON serializable Python object to send in the body of the Request. **kwargs \u2013 Optional arguments that request takes. Returns Response object Return type requests.Response requests.patch(url, data=None, **kwargs)[source] Sends a PATCH request. Parameters url \u2013 URL for the new Request object. data \u2013 (optional) Dictionary, list of tuples, bytes, or file-like object to send in the body of the Request. json \u2013 (optional) A JSON serializable Python object to send in the body of the Request. **kwargs \u2013 Optional arguments that request takes. Returns Response object Return type requests.Response requests.delete(url, **kwargs)[source] Sends a DELETE request. Parameters url \u2013 URL for the new Request object. **kwargs \u2013 Optional arguments that request takes. Returns Response object Return type requests.Response Exceptions exception requests.RequestException(*args, **kwargs)[source] There was an ambiguous exception that occurred while handling your request. exception requests.ConnectionError(*args, **kwargs)[source] A Connection error occurred. exception requests.HTTPError(*args, **kwargs)[source] An HTTP error occurred. exception requests.URLRequired(*args, **kwargs)[source] A valid URL is required to make a request. exception requests.TooManyRedirects(*args, **kwargs)[source] Too many redirects. exception requests.ConnectTimeout(*args, **kwargs)[source] The request timed out while trying to connect to the remote server. Requests that produced this error are safe to retry. exception requests.ReadTimeout(*args, **kwargs)[source] The server did not send any data in the allotted amount of time. exception requests.Timeout(*args, **kwargs)[source] The request timed out. Catching this error will catch both ConnectTimeout and ReadTimeout errors. exception requests.JSONDecodeError(*args, **kwargs)[source] Couldn\u2019t decode the text into json Request Sessions class requests.Session[source] A Requests session. Provides cookie persistence, connection-pooling, and configuration. Basic Usage: >>> import requests >>> s = requests.Session() >>> s.get('https://httpbin.org/get') <Response [200]> Or as a context manager: >>> with requests.Session() as s: ... s.get('https://httpbin.org/get') <Response [200]> auth Default Authentication tuple or object to attach to Request. cert SSL client certificate default, if String, path to ssl client cert file (.pem). If Tuple, (\u2018cert\u2019, \u2018key\u2019) pair. close()[source] Closes all adapters and as such the session cookies A CookieJar containing all currently outstanding cookies set on this session. By default it is a RequestsCookieJar, but may be any other cookielib.CookieJar compatible object. delete(url, **kwargs)[source] Sends a DELETE request. Returns Response object. Parameters url \u2013 URL for the new Request object. **kwargs \u2013 Optional arguments that request takes. Return type requests.Response get(url, **kwargs)[source] Sends a GET request. Returns Response object. Parameters url \u2013 URL for the new Request object. **kwargs \u2013 Optional arguments that request takes. Return type requests.Response get_adapter(url)[source] Returns the appropriate connection adapter for the given URL. Return type requests.adapters.BaseAdapter get_redirect_target(resp) Receives a Response. Returns a redirect URI or None head(url, **kwargs)[source] Sends a HEAD request. Returns Response object. Parameters url \u2013 URL for the new Request object. **kwargs \u2013 Optional arguments that request takes. Return type requests.Response headers A case-insensitive dictionary of headers to be sent on each Request sent from this Session. hooks Event-handling hooks. max_redirects Maximum number of redirects allowed. If the request exceeds this limit, a TooManyRedirects exception is raised. This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is 30. merge_environment_settings(url, proxies, stream, verify, cert)[source] Check the environment and merge it with some settings. Return type dict mount(prefix, adapter)[source] Registers a connection adapter to a prefix. Adapters are sorted in descending order by prefix length. options(url, **kwargs)[source] Sends a OPTIONS request. Returns Response object. Parameters url \u2013 URL for the new Request object. **kwargs \u2013 Optional arguments that request takes. Return type requests.Response params Dictionary of querystring data to attach to each Request. The dictionary values may be lists for representing multivalued query parameters. patch(url, data=None, **kwargs)[source] Sends a PATCH request. Returns Response object. Parameters url \u2013 URL for the new Request object. data \u2013 (optional) Dictionary, list of tuples, bytes, or file-like object to send in the body of the Request. **kwargs \u2013 Optional arguments that request takes. Return type requests.Response post(url, data=None, json=None, **kwargs)[source] Sends a POST request. Returns Response object. Parameters url \u2013 URL for the new Request object. data \u2013 (optional) Dictionary, list of tuples, bytes, or file-like object to send in the body of the Request. json \u2013 (optional) json to send in the body of the Request. **kwargs \u2013 Optional arguments that request takes. Return type requests.Response prepare_request(request)[source] Constructs a PreparedRequest for transmission and returns it. The PreparedRequest has settings merged from the Request instance and those of the Session. Parameters request \u2013 Request instance to prepare with this session\u2019s settings. Return type requests.PreparedRequest proxies Dictionary mapping protocol or protocol and host to the URL of the proxy (e.g. {\u2018http\u2019: \u2018foo.bar:3128\u2019, \u2018http://host.name\u2019: \u2018foo.bar:4012\u2019}) to be used on each Request. put(url, data=None, **kwargs)[source] Sends a PUT request. Returns Response object. Parameters url \u2013 URL for the new Request object. data \u2013 (optional) Dictionary, list of tuples, bytes, or file-like object to send in the body of the Request. **kwargs \u2013 Optional arguments that request takes. Return type requests.Response rebuild_auth(prepared_request, response) When being redirected we may want to strip authentication from the request to avoid leaking credentials. This method intelligently removes and reapplies authentication where possible to avoid credential loss. rebuild_method(prepared_request, response) When being redirected we may want to change the method of the request based on certain specs or browser behavior. rebuild_proxies(prepared_request, proxies) This method re-evaluates the proxy configuration by considering the environment variables. If we are redirected to a URL covered by NO_PROXY, we strip the proxy configuration. Otherwise, we set missing proxy keys for this URL (in case they were stripped by a previous redirect). This method also replaces the Proxy-Authorization header where necessary. Return type dict request(method, url, params=None, data=None, headers=None, cookies=None, files=None, auth=None, timeout=None, allow_redirects=True, proxies=None, hooks=None, stream=None, verify=None, cert=None, json=None)[source] Constructs a Request, prepares it and sends it. Returns Response object. Parameters method \u2013 method for the new Request object. url \u2013 URL for the new Request object. params \u2013 (optional) Dictionary or bytes to be sent in the query string for the Request. data \u2013 (optional) Dictionary, list of tuples, bytes, or file-like object to send in the body of the Request. json \u2013 (optional) json to send in the body of the Request. headers \u2013 (optional) Dictionary of HTTP Headers to send with the Request. cookies \u2013 (optional) Dict or CookieJar object to send with the Request. files \u2013 (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload. auth \u2013 (optional) Auth tuple or callable to enable Basic/Digest/Custom HTTP Auth. timeout (float or tuple) \u2013 (optional) How long to wait for the server to send data before giving up, as a float, or a (connect timeout, read timeout) tuple. allow_redirects (bool) \u2013 (optional) Set to True by default. proxies \u2013 (optional) Dictionary mapping protocol or protocol and hostname to the URL of the proxy. stream \u2013 (optional) whether to immediately download the response content. Defaults to False. verify \u2013 (optional) Either a boolean, in which case it controls whether we verify the server\u2019s TLS certificate, or a string, in which case it must be a path to a CA bundle to use. Defaults to True. When set to False, requests will accept any TLS certificate presented by the server, and will ignore hostname mismatches and/or expired certificates, which will make your application vulnerable to man-in-the-middle (MitM) attacks. Setting verify to False may be useful during local development or testing. cert \u2013 (optional) if String, path to ssl client cert file (.pem). If Tuple, (\u2018cert\u2019, \u2018key\u2019) pair. Return type requests.Response resolve_redirects(resp, req, stream=False, timeout=None, verify=True, cert=None, proxies=None, yield_requests=False, **adapter_kwargs) Receives a Response. Returns a generator of Responses or Requests. send(request, **kwargs)[source] Send a given PreparedRequest. Return type requests.Response should_strip_auth(old_url, new_url) Decide whether Authorization header should be removed when redirecting stream Stream response content default. trust_env Trust environment settings for proxy configuration, default authentication and similar. verify SSL Verification default. Defaults to True, requiring requests to verify the TLS certificate at the remote end. If verify is set to False, requests will accept any TLS certificate presented by the server, and will ignore hostname mismatches and/or expired certificates, which will make your application vulnerable to man-in-the-middle (MitM) attacks. Only set this to False for testing. Lower-Level Classes class requests.Request(method=None, url=None, headers=None, files=None, data=None, params=None, auth=None, cookies=None, hooks=None, json=None)[source] A user-created Request object. Used to prepare a PreparedRequest, which is sent to the server. Parameters method \u2013 HTTP method to use. url \u2013 URL to send. headers \u2013 dictionary of headers to send. files \u2013 dictionary of {filename: fileobject} files to multipart upload. data \u2013 the body to attach to the request. If a dictionary or list of tuples [(key, value)] is provided, form-encoding will take place. json \u2013 json for the body to attach to the request (if files or data is not specified). params \u2013 URL parameters to append to the URL. If a dictionary or list of tuples [(key, value)] is provided, form-encoding will take place. auth \u2013 Auth handler or (user, pass) tuple. cookies \u2013 dictionary or CookieJar of cookies to attach to this request. hooks \u2013 dictionary of callback hooks, for internal usage. Usage: >>> import requests >>> req = requests.Request('GET', 'https://httpbin.org/get') >>> req.prepare() <PreparedRequest [GET]> deregister_hook(event, hook) Deregister a previously registered hook. Returns True if the hook existed, False if not. prepare()[source] Constructs a PreparedRequest for transmission and returns it. register_hook(event, hook) Properly register a hook. class requests.Response[source] The Response object, which contains a server\u2019s response to an HTTP request. property apparent_encoding The apparent encoding, provided by the charset_normalizer or chardet libraries. close()[source] Releases the connection back to the pool. Once this method has been called the underlying raw object must not be accessed again. Note: Should not normally need to be called explicitly. property content Content of the response, in bytes. cookies A CookieJar of Cookies the server sent back. elapsed The amount of time elapsed between sending the request and the arrival of the response (as a timedelta). This property specifically measures the time taken between sending the first byte of the request and finishing parsing the headers. It is therefore unaffected by consuming the response content or the value of the stream keyword argument. encoding Encoding to decode with when accessing r.text. headers Case-insensitive Dictionary of Response Headers. For example, headers['content-encoding'] will return the value of a 'Content-Encoding' response header. history A list of Response objects from the history of the Request. Any redirect responses will end up here. The list is sorted from the oldest to the most recent request. property is_permanent_redirect True if this Response one of the permanent versions of redirect. property is_redirect True if this Response is a well-formed HTTP redirect that could have been processed automatically (by Session.resolve_redirects). iter_content(chunk_size=1, decode_unicode=False)[source] Iterates over the response data. When stream=True is set on the request, this avoids reading the content at once into memory for large responses. The chunk size is the number of bytes it should read into memory. This is not necessarily the length of each item returned as decoding can take place. chunk_size must be of type int or None. A value of None will function differently depending on the value of stream. stream=True will read data as it arrives in whatever size the chunks are received. If stream=False, data is returned as a single chunk. If decode_unicode is True, content will be decoded using the best available encoding based on the response. iter_lines(chunk_size=512, decode_unicode=False, delimiter=None)[source] Iterates over the response data, one line at a time. When stream=True is set on the request, this avoids reading the content at once into memory for large responses. Note This method is not reentrant safe. json(**kwargs)[source] Returns the json-encoded content of a response, if any. Parameters **kwargs \u2013 Optional arguments that json.loads takes. Raises requests.exceptions.JSONDecodeError \u2013 If the response body does not contain valid json. property links Returns the parsed header links of the response, if any. property next Returns a PreparedRequest for the next request in a redirect chain, if there is one. property ok Returns True if status_code is less than 400, False if not. This attribute checks if the status code of the response is between 400 and 600 to see if there was a client error or a server error. If the status code is between 200 and 400, this will return True. This is not a check to see if the response code is 200 OK. raise_for_status()[source] Raises HTTPError, if one occurred. raw File-like object representation of response (for advanced usage). Use of raw requires that stream=True be set on the request. This requirement does not apply for use internally to Requests. reason Textual reason of responded HTTP Status, e.g. \u201cNot Found\u201d or \u201cOK\u201d. request The PreparedRequest object to which this is a response. status_code Integer Code of responded HTTP Status, e.g. 404 or 200. property text Content of the response, in unicode. If Response.encoding is None, encoding will be guessed using charset_normalizer or chardet. The encoding of the response content is determined based solely on HTTP headers, following RFC 2616 to the letter. If you can take advantage of non-HTTP knowledge to make a better guess at the encoding, you should set r.encoding appropriately before accessing this property. url Final URL location of Response. Lower-Lower-Level Classes class requests.PreparedRequest[source] The fully mutable PreparedRequest object, containing the exact bytes that will be sent to the server. Instances are generated from a Request object, and should not be instantiated manually; doing so may produce undesirable effects. Usage: >>> import requests >>> req = requests.Request('GET', 'https://httpbin.org/get') >>> r = req.prepare() >>> r <PreparedRequest [GET]> >>> s = requests.Session() >>> s.send(r) <Response [200]> body request body to send to the server. deregister_hook(event, hook) Deregister a previously registered hook. Returns True if the hook existed, False if not. headers dictionary of HTTP headers. hooks dictionary of callback hooks, for internal usage. method HTTP verb to send to the server. property path_url Build the path URL to use. prepare(method=None, url=None, headers=None, files=None, data=None, params=None, auth=None, cookies=None, hooks=None, json=None)[source] Prepares the entire request with the given parameters. prepare_auth(auth, url='')[source] Prepares the given HTTP auth data. prepare_body(data, files, json=None)[source] Prepares the given HTTP body data. prepare_content_length(body)[source] Prepare Content-Length header based on request method and body prepare_cookies(cookies)[source] Prepares the given HTTP cookie data. This function eventually generates a Cookie header from the given cookies using cookielib. Due to cookielib\u2019s design, the header will not be regenerated if it already exists, meaning this function can only be called once for the life of the PreparedRequest object. Any subsequent calls to prepare_cookies will have no actual effect, unless the \u201cCookie\u201d header is removed beforehand. prepare_headers(headers)[source] Prepares the given HTTP headers. prepare_hooks(hooks)[source] Prepares the given hooks. prepare_method(method)[source] Prepares the given HTTP method. prepare_url(url, params)[source] Prepares the given HTTP URL. register_hook(event, hook) Properly register a hook. url HTTP URL to send the request to. class requests.adapters.BaseAdapter[source] The Base Transport Adapter close()[source] Cleans up adapter specific items. send(request, stream=False, timeout=None, verify=True, cert=None, proxies=None)[source] Sends PreparedRequest object. Returns Response object. Parameters request \u2013 The PreparedRequest being sent. stream \u2013 (optional) Whether to stream the request content. timeout (float or tuple) \u2013 (optional) How long to wait for the server to send data before giving up, as a float, or a (connect timeout, read timeout) tuple. verify \u2013 (optional) Either a boolean, in which case it controls whether we verify the server\u2019s TLS certificate, or a string, in which case it must be a path to a CA bundle to use cert \u2013 (optional) Any user-provided SSL certificate to be trusted. proxies \u2013 (optional) The proxies dictionary to apply to the request. class requests.adapters.HTTPAdapter(pool_connections=10, pool_maxsize=10, max_retries=0, pool_block=False)[source] The built-in HTTP Adapter for urllib3. Provides a general-case interface for Requests sessions to contact HTTP and HTTPS urls by implementing the Transport Adapter interface. This class will usually be created by the Session class under the covers. Parameters pool_connections \u2013 The number of urllib3 connection pools to cache. pool_maxsize \u2013 The maximum number of connections to save in the pool. max_retries \u2013 The maximum number of retries each connection should attempt. Note, this applies only to failed DNS lookups, socket connections and connection timeouts, never to requests where data has made it to the server. By default, Requests does not retry failed connections. If you need granular control over the conditions under which we retry a request, import urllib3\u2019s Retry class and pass that instead. pool_block \u2013 Whether the connection pool should block for connections. Usage: >>> import requests >>> s = requests.Session() >>> a = requests.adapters.HTTPAdapter(max_retries=3) >>> s.mount('http://', a) add_headers(request, **kwargs)[source] Add any headers needed by the connection. As of v2.0 this does nothing by default, but is left for overriding by users that subclass the HTTPAdapter. This should not be called from user code, and is only exposed for use when subclassing the HTTPAdapter. Parameters request \u2013 The PreparedRequest to add headers to. kwargs \u2013 The keyword arguments from the call to send(). build_response(req, resp)[source] Builds a Response object from a urllib3 response. This should not be called from user code, and is only exposed for use when subclassing the HTTPAdapter Parameters req \u2013 The PreparedRequest used to generate the response. resp \u2013 The urllib3 response object. Return type requests.Response cert_verify(conn, url, verify, cert)[source] Verify a SSL certificate. This method should not be called from user code, and is only exposed for use when subclassing the HTTPAdapter. Parameters conn \u2013 The urllib3 connection object associated with the cert. url \u2013 The requested URL. verify \u2013 Either a boolean, in which case it controls whether we verify the server\u2019s TLS certificate, or a string, in which case it must be a path to a CA bundle to use cert \u2013 The SSL certificate to verify. close()[source] Disposes of any internal state. Currently, this closes the PoolManager and any active ProxyManager, which closes any pooled connections. get_connection(url, proxies=None)[source] Returns a urllib3 connection for the given URL. This should not be called from user code, and is only exposed for use when subclassing the HTTPAdapter. Parameters url \u2013 The URL to connect to. proxies \u2013 (optional) A Requests-style dictionary of proxies used on this request. Return type urllib3.ConnectionPool init_poolmanager(connections, maxsize, block=False, **pool_kwargs)[source] Initializes a urllib3 PoolManager. This method should not be called from user code, and is only exposed for use when subclassing the HTTPAdapter. Parameters connections \u2013 The number of urllib3 connection pools to cache. maxsize \u2013 The maximum number of connections to save in the pool. block \u2013 Block when no free connections are available. pool_kwargs \u2013 Extra keyword arguments used to initialize the Pool Manager. proxy_headers(proxy)[source] Returns a dictionary of the headers to add to any request sent through a proxy. This works with urllib3 magic to ensure that they are correctly sent to the proxy, rather than in a tunnelled request if CONNECT is being used. This should not be called from user code, and is only exposed for use when subclassing the HTTPAdapter. Parameters proxy \u2013 The url of the proxy being used for this request. Return type dict proxy_manager_for(proxy, **proxy_kwargs)[source] Return urllib3 ProxyManager for the given proxy. This method should not be called from user code, and is only exposed for use when subclassing the HTTPAdapter. Parameters proxy \u2013 The proxy to return a urllib3 ProxyManager for. proxy_kwargs \u2013 Extra keyword arguments used to configure the Proxy Manager. Returns ProxyManager Return type urllib3.ProxyManager request_url(request, proxies)[source] Obtain the url to use when making the final request. If the message is being sent through a HTTP proxy, the full URL has to be used. Otherwise, we should only use the path portion of the URL. This should not be called from user code, and is only exposed for use when subclassing the HTTPAdapter. Parameters request \u2013 The PreparedRequest being sent. proxies \u2013 A dictionary of schemes or schemes and hosts to proxy URLs. Return type str send(request, stream=False, timeout=None, verify=True, cert=None, proxies=None)[source] Sends PreparedRequest object. Returns Response object. Parameters request \u2013 The PreparedRequest being sent. stream \u2013 (optional) Whether to stream the request content. timeout (float or tuple or urllib3 Timeout object) \u2013 (optional) How long to wait for the server to send data before giving up, as a float, or a (connect timeout, read timeout) tuple. verify \u2013 (optional) Either a boolean, in which case it controls whether we verify the server\u2019s TLS certificate, or a string, in which case it must be a path to a CA bundle to use cert \u2013 (optional) Any user-provided SSL certificate to be trusted. proxies \u2013 (optional) The proxies dictionary to apply to the request. Return type requests.Response Authentication class requests.auth.AuthBase[source] Base class that all auth implementations derive from class requests.auth.HTTPBasicAuth(username, password)[source] Attaches HTTP Basic Authentication to the given Request object. class requests.auth.HTTPProxyAuth(username, password)[source] Attaches HTTP Proxy Authentication to a given Request object. class requests.auth.HTTPDigestAuth(username, password)[source] Attaches HTTP Digest Authentication to the given Request object. Encodings requests.utils.get_encodings_from_content(content)[source] Returns encodings from given content string. Parameters content \u2013 bytestring to extract encodings from. requests.utils.get_encoding_from_headers(headers)[source] Returns encodings from given HTTP Header Dict. Parameters headers \u2013 dictionary to extract encoding from. Return type str requests.utils.get_unicode_from_response(r)[source] Returns the requested content back in unicode. Parameters r \u2013 Response object to get unicode content from. Tried: charset from content-type fall back and replace all unicode characters Return type str Cookies requests.utils.dict_from_cookiejar(cj)[source] Returns a key/value dictionary from a CookieJar. Parameters cj \u2013 CookieJar object to extract cookies from. Return type dict requests.utils.add_dict_to_cookiejar(cj, cookie_dict)[source] Returns a CookieJar from a key/value dictionary. Parameters cj \u2013 CookieJar to insert cookies into. cookie_dict \u2013 Dict of key/values to insert into CookieJar. Return type CookieJar requests.cookies.cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True)[source] Returns a CookieJar from a key/value dictionary. Parameters cookie_dict \u2013 Dict of key/values to insert into CookieJar. cookiejar \u2013 (optional) A cookiejar to add the cookies to. overwrite \u2013 (optional) If False, will not replace cookies already in the jar with new ones. Return type CookieJar class requests.cookies.RequestsCookieJar(policy=None)[source] Compatibility class; is a cookielib.CookieJar, but exposes a dict interface. This is the CookieJar we create by default for requests and sessions that don\u2019t specify one, since some clients may expect response.cookies and session.cookies to support dict operations. Requests does not use the dict interface internally; it\u2019s just for compatibility with external client code. All requests code should work out of the box with externally provided instances of CookieJar, e.g. LWPCookieJar and FileCookieJar. Unlike a regular CookieJar, this class is pickleable. Warning dictionary operations that are normally O(1) may be O(n). add_cookie_header(request) Add correct Cookie: header to request (urllib.request.Request object). The Cookie2 header is also added unless policy.hide_cookie2 is true. clear(domain=None, path=None, name=None) Clear some cookies. Invoking this method without arguments will clear all cookies. If given a single argument, only cookies belonging to that domain will be removed. If given two arguments, cookies belonging to the specified path within that domain are removed. If given three arguments, then the cookie with the specified name, path and domain is removed. Raises KeyError if no matching cookie exists. clear_expired_cookies() Discard all expired cookies. You probably don\u2019t need to call this method: expired cookies are never sent back to the server (provided you\u2019re using DefaultCookiePolicy), this method is called by CookieJar itself every so often, and the .save() method won\u2019t save expired cookies anyway (unless you ask otherwise by passing a true ignore_expires argument). clear_session_cookies() Discard all session cookies. Note that the .save() method won\u2019t save session cookies anyway, unless you ask otherwise by passing a true ignore_discard argument. copy()[source] Return a copy of this RequestsCookieJar. extract_cookies(response, request) Extract cookies from response, where allowable given the request. get(name, default=None, domain=None, path=None)[source] Dict-like get() that also supports optional domain and path args in order to resolve naming collisions from using one cookie jar over multiple domains. Warning operation is O(n), not O(1). get_dict(domain=None, path=None)[source] Takes as an argument an optional domain and path and returns a plain old Python dict of name-value pairs of cookies that meet the requirements. Return type dict get_policy()[source] Return the CookiePolicy instance used. items()[source] Dict-like items() that returns a list of name-value tuples from the jar. Allows client-code to call dict(RequestsCookieJar) and get a vanilla python dict of key value pairs. See also keys() and values(). iteritems()[source] Dict-like iteritems() that returns an iterator of name-value tuples from the jar. See also iterkeys() and itervalues(). iterkeys()[source] Dict-like iterkeys() that returns an iterator of names of cookies from the jar. See also itervalues() and iteritems(). itervalues()[source] Dict-like itervalues() that returns an iterator of values of cookies from the jar. See also iterkeys() and iteritems(). keys()[source] Dict-like keys() that returns a list of names of cookies from the jar. See also values() and items(). list_domains()[source] Utility method to list all the domains in the jar. list_paths()[source] Utility method to list all the paths in the jar. make_cookies(response, request) Return sequence of Cookie objects extracted from response object. multiple_domains()[source] Returns True if there are multiple domains in the jar. Returns False otherwise. Return type bool pop(k[, d]) \u2192 v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. popitem() \u2192 (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. set(name, value, **kwargs)[source] Dict-like set() that also supports optional domain and path args in order to resolve naming collisions from using one cookie jar over multiple domains. set_cookie(cookie, *args, **kwargs)[source] Set a cookie, without checking whether or not it should be set. set_cookie_if_ok(cookie, request) Set a cookie if policy says it\u2019s OK to do so. setdefault(k[, d]) \u2192 D.get(k,d), also set D[k]=d if k not in D update(other)[source] Updates this jar with cookies from another CookieJar or dict-like values()[source] Dict-like values() that returns a list of values of cookies from the jar. See also keys() and items(). class requests.cookies.CookieConflictError[source] There are two cookies that meet the criteria specified in the cookie jar. Use .get and .set and include domain and path args in order to be more specific. with_traceback() Exception.with_traceback(tb) \u2013 set self.__traceback__ to tb and return self. Status Code Lookup requests.codes alias of <lookup \u2018status_codes\u2019> The codes object defines a mapping from common names for HTTP statuses to their numerical codes, accessible either as attributes or as dictionary items. Example: >>> import requests >>> requests.codes['temporary_redirect'] 307 >>> requests.codes.teapot 418 >>> requests.codes['\\o/'] 200 Some codes have multiple names, and both upper- and lower-case versions of the names are allowed. For example, codes.ok, codes.OK, and codes.okay all correspond to the HTTP status code 200. 100: continue 101: switching_protocols 102: processing 103: checkpoint 122: uri_too_long, request_uri_too_long 200: ok, okay, all_ok, all_okay, all_good, \\o/, \u2713 201: created 202: accepted 203: non_authoritative_info, non_authoritative_information 204: no_content 205: reset_content, reset 206: partial_content, partial 207: multi_status, multiple_status, multi_stati, multiple_stati 208: already_reported 226: im_used 300: multiple_choices 301: moved_permanently, moved, \\o- 302: found 303: see_other, other 304: not_modified 305: use_proxy 306: switch_proxy 307: temporary_redirect, temporary_moved, temporary 308: permanent_redirect, resume_incomplete, resume 400: bad_request, bad 401: unauthorized 402: payment_required, payment 403: forbidden 404: not_found, -o- 405: method_not_allowed, not_allowed 406: not_acceptable 407: proxy_authentication_required, proxy_auth, proxy_authentication 408: request_timeout, timeout 409: conflict 410: gone 411: length_required 412: precondition_failed, precondition 413: request_entity_too_large 414: request_uri_too_large 415: unsupported_media_type, unsupported_media, media_type 416: requested_range_not_satisfiable, requested_range, range_not_satisfiable 417: expectation_failed 418: im_a_teapot, teapot, i_am_a_teapot 421: misdirected_request 422: unprocessable_entity, unprocessable 423: locked 424: failed_dependency, dependency 425: unordered_collection, unordered 426: upgrade_required, upgrade 428: precondition_required, precondition 429: too_many_requests, too_many 431: header_fields_too_large, fields_too_large 444: no_response, none 449: retry_with, retry 450: blocked_by_windows_parental_controls, parental_controls 451: unavailable_for_legal_reasons, legal_reasons 499: client_closed_request 500: internal_server_error, server_error, /o\\, \u2717 501: not_implemented 502: bad_gateway 503: service_unavailable, unavailable 504: gateway_timeout 505: http_version_not_supported, http_version 506: variant_also_negotiates 507: insufficient_storage 509: bandwidth_limit_exceeded, bandwidth 510: not_extended 511: network_authentication_required, network_auth, network_authentication Migrating to 1.x This section details the main differences between 0.x and 1.x and is meant to ease the pain of upgrading. API Changes Response.json is now a callable and not a property of a response. import requests r = requests.get('https://api.github.com/events') r.json() # This *call* raises an exception if JSON decoding fails The Session API has changed. Sessions objects no longer take parameters. Session is also now capitalized, but it can still be instantiated with a lowercase session for backwards compatibility. s = requests.Session() # formerly, session took parameters s.auth = auth s.headers.update(headers) r = s.get('https://httpbin.org/headers') All request hooks have been removed except \u2018response\u2019. Authentication helpers have been broken out into separate modules. See requests-oauthlib and requests-kerberos. The parameter for streaming requests was changed from prefetch to stream and the logic was inverted. In addition, stream is now required for raw response reading. # in 0.x, passing prefetch=False would accomplish the same thing r = requests.get('https://api.github.com/events', stream=True) for chunk in r.iter_content(8192): ... The config parameter to the requests method has been removed. Some of these options are now configured on a Session such as keep-alive and maximum number of redirects. The verbosity option should be handled by configuring logging. import requests import logging # Enabling debugging at http.client level (requests->urllib3->http.client) # you will see the REQUEST, including HEADERS and DATA, and RESPONSE with HEADERS but without DATA. # the only thing missing will be the response.body which is not logged. try: # for Python 3 from http.client import HTTPConnection except ImportError: from httplib import HTTPConnection HTTPConnection.debuglevel = 1 logging.basicConfig() # you need to initialize logging, otherwise you will not see anything from requests logging.getLogger().setLevel(logging.DEBUG) requests_log = logging.getLogger(\"urllib3\") requests_log.setLevel(logging.DEBUG) requests_log.propagate = True requests.get('https://httpbin.org/headers') Licensing One key difference that has nothing to do with the API is a change in the license from the ISC license to the Apache 2.0 license. The Apache 2.0 license ensures that contributions to Requests are also covered by the Apache 2.0 license. Migrating to 2.x Compared with the 1.0 release, there were relatively few backwards incompatible changes, but there are still a few issues to be aware of with this major release. For more details on the changes in this release including new APIs, links to the relevant GitHub issues and some of the bug fixes, read Cory\u2019s blog on the subject. API Changes There were a couple changes to how Requests handles exceptions. RequestException is now a subclass of IOError rather than RuntimeError as that more accurately categorizes the type of error. In addition, an invalid URL escape sequence now raises a subclass of RequestException rather than a ValueError. requests.get('http://%zz/') # raises requests.exceptions.InvalidURL Lastly, httplib.IncompleteRead exceptions caused by incorrect chunked encoding will now raise a Requests ChunkedEncodingError instead. The proxy API has changed slightly. The scheme for a proxy URL is now required. proxies = { \"http\": \"10.10.1.10:3128\", # use http://10.10.1.10:3128 instead } # In requests 1.x, this was legal, in requests 2.x, # this raises requests.exceptions.MissingSchema requests.get(\"http://example.org\", proxies=proxies) Behavioural Changes Keys in the headers dictionary are now native strings on all Python versions, i.e. bytestrings on Python 2 and unicode on Python 3. If the keys are not native strings (unicode on Python 2 or bytestrings on Python 3) they will be converted to the native string type assuming UTF-8 encoding. Values in the headers dictionary should always be strings. This has been the project\u2019s position since before 1.0 but a recent change (since version 2.11.0) enforces this more strictly. It\u2019s advised to avoid passing header values as unicode when possible. \u00a9MMXVIX. A Kenneth Reitz Project."
    },
    {
      "id": "requests.request",
      "title": "requests.request(method, url, **kwargs)[source]",
      "content": "Constructs and sends a Request.\n\nParameters\n\nmethod \u2013 method for the new Request object: GET, OPTIONS, HEAD, POST, PUT, PATCH, or DELETE.\nurl \u2013 URL for the new Request object.\nparams \u2013 (optional) Dictionary, list of tuples or bytes to send\nin the query string for the Request.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\njson \u2013 (optional) A JSON serializable Python object to send in the body of the Request.\nheaders \u2013 (optional) Dictionary of HTTP Headers to send with the Request.\ncookies \u2013 (optional) Dict or CookieJar object to send with the Request.\nfiles \u2013 (optional) Dictionary of 'name': file-like-objects (or {'name': file-tuple}) for multipart encoding upload.\nfile-tuple can be a 2-tuple ('filename', fileobj), 3-tuple ('filename', fileobj, 'content_type')\nor a 4-tuple ('filename', fileobj, 'content_type', custom_headers), where 'content-type' is a string\ndefining the content type of the given file and custom_headers a dict-like object containing additional headers\nto add for the file.\nauth \u2013 (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.\ntimeout (float or tuple) \u2013 (optional) How many seconds to wait for the server to send data\nbefore giving up, as a float, or a (connect timeout, read\ntimeout) tuple.\nallow_redirects (bool) \u2013 (optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection. Defaults to True.\nproxies \u2013 (optional) Dictionary mapping protocol to the URL of the proxy.\nverify \u2013 (optional) Either a boolean, in which case it controls whether we verify\nthe server\u2019s TLS certificate, or a string, in which case it must be a path\nto a CA bundle to use. Defaults to True.\nstream \u2013 (optional) if False, the response content will be immediately downloaded.\ncert \u2013 (optional) if String, path to ssl client cert file (.pem). If Tuple, (\u2018cert\u2019, \u2018key\u2019) pair.\n\n\nReturns\nResponse object\n\nReturn type\nrequests.Response\n\n\nUsage:\n>>> import requests\n>>> req = requests.request('GET', 'https://httpbin.org/get')\n>>> req\n<Response [200]>\n\n\n"
    },
    {
      "id": "requests.head",
      "title": "requests.head(url, **kwargs)[source]",
      "content": "Sends a HEAD request.\n\nParameters\n\nurl \u2013 URL for the new Request object.\n**kwargs \u2013 Optional arguments that request takes. If\nallow_redirects is not provided, it will be set to False (as\nopposed to the default request behavior).\n\n\nReturns\nResponse object\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.get",
      "title": "requests.get(url, params=None, **kwargs)[source]",
      "content": "Sends a GET request.\n\nParameters\n\nurl \u2013 URL for the new Request object.\nparams \u2013 (optional) Dictionary, list of tuples or bytes to send\nin the query string for the Request.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturns\nResponse object\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.post",
      "title": "requests.post(url, data=None, json=None, **kwargs)[source]",
      "content": "Sends a POST request.\n\nParameters\n\nurl \u2013 URL for the new Request object.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\njson \u2013 (optional) A JSON serializable Python object to send in the body of the Request.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturns\nResponse object\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.put",
      "title": "requests.put(url, data=None, **kwargs)[source]",
      "content": "Sends a PUT request.\n\nParameters\n\nurl \u2013 URL for the new Request object.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\njson \u2013 (optional) A JSON serializable Python object to send in the body of the Request.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturns\nResponse object\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.patch",
      "title": "requests.patch(url, data=None, **kwargs)[source]",
      "content": "Sends a PATCH request.\n\nParameters\n\nurl \u2013 URL for the new Request object.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\njson \u2013 (optional) A JSON serializable Python object to send in the body of the Request.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturns\nResponse object\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.delete",
      "title": "requests.delete(url, **kwargs)[source]",
      "content": "Sends a DELETE request.\n\nParameters\n\nurl \u2013 URL for the new Request object.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturns\nResponse object\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.RequestException",
      "title": "exception requests.RequestException(*args, **kwargs)[source]",
      "content": "There was an ambiguous exception that occurred while handling your\nrequest.\n"
    },
    {
      "id": "requests.ConnectionError",
      "title": "exception requests.ConnectionError(*args, **kwargs)[source]",
      "content": "A Connection error occurred.\n"
    },
    {
      "id": "requests.HTTPError",
      "title": "exception requests.HTTPError(*args, **kwargs)[source]",
      "content": "An HTTP error occurred.\n"
    },
    {
      "id": "requests.URLRequired",
      "title": "exception requests.URLRequired(*args, **kwargs)[source]",
      "content": "A valid URL is required to make a request.\n"
    },
    {
      "id": "requests.TooManyRedirects",
      "title": "exception requests.TooManyRedirects(*args, **kwargs)[source]",
      "content": "Too many redirects.\n"
    },
    {
      "id": "requests.ConnectTimeout",
      "title": "exception requests.ConnectTimeout(*args, **kwargs)[source]",
      "content": "The request timed out while trying to connect to the remote server.\nRequests that produced this error are safe to retry.\n"
    },
    {
      "id": "requests.ReadTimeout",
      "title": "exception requests.ReadTimeout(*args, **kwargs)[source]",
      "content": "The server did not send any data in the allotted amount of time.\n"
    },
    {
      "id": "requests.Timeout",
      "title": "exception requests.Timeout(*args, **kwargs)[source]",
      "content": "The request timed out.\nCatching this error will catch both\nConnectTimeout and\nReadTimeout errors.\n"
    },
    {
      "id": "requests.JSONDecodeError",
      "title": "exception requests.JSONDecodeError(*args, **kwargs)[source]",
      "content": "Couldn\u2019t decode the text into json\n"
    },
    {
      "id": "requests.Session",
      "title": "class requests.Session[source]",
      "content": "A Requests session.\nProvides cookie persistence, connection-pooling, and configuration.\nBasic Usage:\n>>> import requests\n>>> s = requests.Session()\n>>> s.get('https://httpbin.org/get')\n<Response [200]>\n\n\nOr as a context manager:\n>>> with requests.Session() as s:\n...     s.get('https://httpbin.org/get')\n<Response [200]>\n\n\n\n\nauth\nDefault Authentication tuple or object to attach to\nRequest.\n\n\n\n\ncert\nSSL client certificate default, if String, path to ssl client\ncert file (.pem). If Tuple, (\u2018cert\u2019, \u2018key\u2019) pair.\n\n\n\n\nclose()[source]\nCloses all adapters and as such the session\n\n\n\n\ncookies\nA CookieJar containing all currently outstanding cookies set on this\nsession. By default it is a\nRequestsCookieJar, but\nmay be any other cookielib.CookieJar compatible object.\n\n\n\n\ndelete(url, **kwargs)[source]\nSends a DELETE request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n\n\n\n\nget(url, **kwargs)[source]\nSends a GET request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n\n\n\n\nget_adapter(url)[source]\nReturns the appropriate connection adapter for the given URL.\n\nReturn type\nrequests.adapters.BaseAdapter\n\n\n\n\n\n\nget_redirect_target(resp)\nReceives a Response. Returns a redirect URI or None\n\n\n\n\nhead(url, **kwargs)[source]\nSends a HEAD request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n\n\n\n\nheaders\nA case-insensitive dictionary of headers to be sent on each\nRequest sent from this\nSession.\n\n\n\n\nhooks\nEvent-handling hooks.\n\n\n\n\nmax_redirects\nMaximum number of redirects allowed. If the request exceeds this\nlimit, a TooManyRedirects exception is raised.\nThis defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n30.\n\n\n\n\nmerge_environment_settings(url, proxies, stream, verify, cert)[source]\nCheck the environment and merge it with some settings.\n\nReturn type\ndict\n\n\n\n\n\n\nmount(prefix, adapter)[source]\nRegisters a connection adapter to a prefix.\nAdapters are sorted in descending order by prefix length.\n\n\n\n\noptions(url, **kwargs)[source]\nSends a OPTIONS request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n\n\n\n\nparams\nDictionary of querystring data to attach to each\nRequest. The dictionary values may be lists for\nrepresenting multivalued query parameters.\n\n\n\n\npatch(url, data=None, **kwargs)[source]\nSends a PATCH request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n\n\n\n\npost(url, data=None, json=None, **kwargs)[source]\nSends a POST request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\njson \u2013 (optional) json to send in the body of the Request.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n\n\n\n\nprepare_request(request)[source]\nConstructs a PreparedRequest for\ntransmission and returns it. The PreparedRequest has settings\nmerged from the Request instance and those of the\nSession.\n\nParameters\nrequest \u2013 Request instance to prepare with this\nsession\u2019s settings.\n\nReturn type\nrequests.PreparedRequest\n\n\n\n\n\n\nproxies\nDictionary mapping protocol or protocol and host to the URL of the proxy\n(e.g. {\u2018http\u2019: \u2018foo.bar:3128\u2019, \u2018http://host.name\u2019: \u2018foo.bar:4012\u2019}) to\nbe used on each Request.\n\n\n\n\nput(url, data=None, **kwargs)[source]\nSends a PUT request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n\n\n\n\nrebuild_auth(prepared_request, response)\nWhen being redirected we may want to strip authentication from the\nrequest to avoid leaking credentials. This method intelligently removes\nand reapplies authentication where possible to avoid credential loss.\n\n\n\n\nrebuild_method(prepared_request, response)\nWhen being redirected we may want to change the method of the request\nbased on certain specs or browser behavior.\n\n\n\n\nrebuild_proxies(prepared_request, proxies)\nThis method re-evaluates the proxy configuration by considering the\nenvironment variables. If we are redirected to a URL covered by\nNO_PROXY, we strip the proxy configuration. Otherwise, we set missing\nproxy keys for this URL (in case they were stripped by a previous\nredirect).\nThis method also replaces the Proxy-Authorization header where\nnecessary.\n\nReturn type\ndict\n\n\n\n\n\n\nrequest(method, url, params=None, data=None, headers=None, cookies=None, files=None, auth=None, timeout=None, allow_redirects=True, proxies=None, hooks=None, stream=None, verify=None, cert=None, json=None)[source]\nConstructs a Request, prepares it and sends it.\nReturns Response object.\n\nParameters\n\nmethod \u2013 method for the new Request object.\nurl \u2013 URL for the new Request object.\nparams \u2013 (optional) Dictionary or bytes to be sent in the query\nstring for the Request.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\njson \u2013 (optional) json to send in the body of the\nRequest.\nheaders \u2013 (optional) Dictionary of HTTP Headers to send with the\nRequest.\ncookies \u2013 (optional) Dict or CookieJar object to send with the\nRequest.\nfiles \u2013 (optional) Dictionary of 'filename': file-like-objects\nfor multipart encoding upload.\nauth \u2013 (optional) Auth tuple or callable to enable\nBasic/Digest/Custom HTTP Auth.\ntimeout (float or tuple) \u2013 (optional) How long to wait for the server to send\ndata before giving up, as a float, or a (connect timeout,\nread timeout) tuple.\nallow_redirects (bool) \u2013 (optional) Set to True by default.\nproxies \u2013 (optional) Dictionary mapping protocol or protocol and\nhostname to the URL of the proxy.\nstream \u2013 (optional) whether to immediately download the response\ncontent. Defaults to False.\nverify \u2013 (optional) Either a boolean, in which case it controls whether we verify\nthe server\u2019s TLS certificate, or a string, in which case it must be a path\nto a CA bundle to use. Defaults to True. When set to\nFalse, requests will accept any TLS certificate presented by\nthe server, and will ignore hostname mismatches and/or expired\ncertificates, which will make your application vulnerable to\nman-in-the-middle (MitM) attacks. Setting verify to False\nmay be useful during local development or testing.\ncert \u2013 (optional) if String, path to ssl client cert file (.pem).\nIf Tuple, (\u2018cert\u2019, \u2018key\u2019) pair.\n\n\nReturn type\nrequests.Response\n\n\n\n\n\n\nresolve_redirects(resp, req, stream=False, timeout=None, verify=True, cert=None, proxies=None, yield_requests=False, **adapter_kwargs)\nReceives a Response. Returns a generator of Responses or Requests.\n\n\n\n\nsend(request, **kwargs)[source]\nSend a given PreparedRequest.\n\nReturn type\nrequests.Response\n\n\n\n\n\n\nshould_strip_auth(old_url, new_url)\nDecide whether Authorization header should be removed when redirecting\n\n\n\n\nstream\nStream response content default.\n\n\n\n\ntrust_env\nTrust environment settings for proxy configuration, default\nauthentication and similar.\n\n\n\n\nverify\nSSL Verification default.\nDefaults to True, requiring requests to verify the TLS certificate at the\nremote end.\nIf verify is set to False, requests will accept any TLS certificate\npresented by the server, and will ignore hostname mismatches and/or\nexpired certificates, which will make your application vulnerable to\nman-in-the-middle (MitM) attacks.\nOnly set this to False for testing.\n\n\n"
    },
    {
      "id": "requests.Session.auth",
      "title": "auth",
      "content": "Default Authentication tuple or object to attach to\nRequest.\n"
    },
    {
      "id": "requests.Session.cert",
      "title": "cert",
      "content": "SSL client certificate default, if String, path to ssl client\ncert file (.pem). If Tuple, (\u2018cert\u2019, \u2018key\u2019) pair.\n"
    },
    {
      "id": "requests.Session.close",
      "title": "close()[source]",
      "content": "Closes all adapters and as such the session\n"
    },
    {
      "id": "requests.Session.cookies",
      "title": "cookies",
      "content": "A CookieJar containing all currently outstanding cookies set on this\nsession. By default it is a\nRequestsCookieJar, but\nmay be any other cookielib.CookieJar compatible object.\n"
    },
    {
      "id": "requests.Session.delete",
      "title": "delete(url, **kwargs)[source]",
      "content": "Sends a DELETE request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.get",
      "title": "get(url, **kwargs)[source]",
      "content": "Sends a GET request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.get_adapter",
      "title": "get_adapter(url)[source]",
      "content": "Returns the appropriate connection adapter for the given URL.\n\nReturn type\nrequests.adapters.BaseAdapter\n\n\n"
    },
    {
      "id": "requests.Session.get_redirect_target",
      "title": "get_redirect_target(resp)",
      "content": "Receives a Response. Returns a redirect URI or None\n"
    },
    {
      "id": "requests.Session.head",
      "title": "head(url, **kwargs)[source]",
      "content": "Sends a HEAD request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.headers",
      "title": "headers",
      "content": "A case-insensitive dictionary of headers to be sent on each\nRequest sent from this\nSession.\n"
    },
    {
      "id": "requests.Session.hooks",
      "title": "hooks",
      "content": "Event-handling hooks.\n"
    },
    {
      "id": "requests.Session.max_redirects",
      "title": "max_redirects",
      "content": "Maximum number of redirects allowed. If the request exceeds this\nlimit, a TooManyRedirects exception is raised.\nThis defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n30.\n"
    },
    {
      "id": "requests.Session.merge_environment_settings",
      "title": "merge_environment_settings(url, proxies, stream, verify, cert)[source]",
      "content": "Check the environment and merge it with some settings.\n\nReturn type\ndict\n\n\n"
    },
    {
      "id": "requests.Session.mount",
      "title": "mount(prefix, adapter)[source]",
      "content": "Registers a connection adapter to a prefix.\nAdapters are sorted in descending order by prefix length.\n"
    },
    {
      "id": "requests.Session.options",
      "title": "options(url, **kwargs)[source]",
      "content": "Sends a OPTIONS request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.params",
      "title": "params",
      "content": "Dictionary of querystring data to attach to each\nRequest. The dictionary values may be lists for\nrepresenting multivalued query parameters.\n"
    },
    {
      "id": "requests.Session.patch",
      "title": "patch(url, data=None, **kwargs)[source]",
      "content": "Sends a PATCH request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.post",
      "title": "post(url, data=None, json=None, **kwargs)[source]",
      "content": "Sends a POST request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\njson \u2013 (optional) json to send in the body of the Request.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.prepare_request",
      "title": "prepare_request(request)[source]",
      "content": "Constructs a PreparedRequest for\ntransmission and returns it. The PreparedRequest has settings\nmerged from the Request instance and those of the\nSession.\n\nParameters\nrequest \u2013 Request instance to prepare with this\nsession\u2019s settings.\n\nReturn type\nrequests.PreparedRequest\n\n\n"
    },
    {
      "id": "requests.Session.proxies",
      "title": "proxies",
      "content": "Dictionary mapping protocol or protocol and host to the URL of the proxy\n(e.g. {\u2018http\u2019: \u2018foo.bar:3128\u2019, \u2018http://host.name\u2019: \u2018foo.bar:4012\u2019}) to\nbe used on each Request.\n"
    },
    {
      "id": "requests.Session.put",
      "title": "put(url, data=None, **kwargs)[source]",
      "content": "Sends a PUT request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.rebuild_auth",
      "title": "rebuild_auth(prepared_request, response)",
      "content": "When being redirected we may want to strip authentication from the\nrequest to avoid leaking credentials. This method intelligently removes\nand reapplies authentication where possible to avoid credential loss.\n"
    },
    {
      "id": "requests.Session.rebuild_method",
      "title": "rebuild_method(prepared_request, response)",
      "content": "When being redirected we may want to change the method of the request\nbased on certain specs or browser behavior.\n"
    },
    {
      "id": "requests.Session.rebuild_proxies",
      "title": "rebuild_proxies(prepared_request, proxies)",
      "content": "This method re-evaluates the proxy configuration by considering the\nenvironment variables. If we are redirected to a URL covered by\nNO_PROXY, we strip the proxy configuration. Otherwise, we set missing\nproxy keys for this URL (in case they were stripped by a previous\nredirect).\nThis method also replaces the Proxy-Authorization header where\nnecessary.\n\nReturn type\ndict\n\n\n"
    },
    {
      "id": "requests.Session.request",
      "title": "request(method, url, params=None, data=None, headers=None, cookies=None, files=None, auth=None, timeout=None, allow_redirects=True, proxies=None, hooks=None, stream=None, verify=None, cert=None, json=None)[source]",
      "content": "Constructs a Request, prepares it and sends it.\nReturns Response object.\n\nParameters\n\nmethod \u2013 method for the new Request object.\nurl \u2013 URL for the new Request object.\nparams \u2013 (optional) Dictionary or bytes to be sent in the query\nstring for the Request.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\njson \u2013 (optional) json to send in the body of the\nRequest.\nheaders \u2013 (optional) Dictionary of HTTP Headers to send with the\nRequest.\ncookies \u2013 (optional) Dict or CookieJar object to send with the\nRequest.\nfiles \u2013 (optional) Dictionary of 'filename': file-like-objects\nfor multipart encoding upload.\nauth \u2013 (optional) Auth tuple or callable to enable\nBasic/Digest/Custom HTTP Auth.\ntimeout (float or tuple) \u2013 (optional) How long to wait for the server to send\ndata before giving up, as a float, or a (connect timeout,\nread timeout) tuple.\nallow_redirects (bool) \u2013 (optional) Set to True by default.\nproxies \u2013 (optional) Dictionary mapping protocol or protocol and\nhostname to the URL of the proxy.\nstream \u2013 (optional) whether to immediately download the response\ncontent. Defaults to False.\nverify \u2013 (optional) Either a boolean, in which case it controls whether we verify\nthe server\u2019s TLS certificate, or a string, in which case it must be a path\nto a CA bundle to use. Defaults to True. When set to\nFalse, requests will accept any TLS certificate presented by\nthe server, and will ignore hostname mismatches and/or expired\ncertificates, which will make your application vulnerable to\nman-in-the-middle (MitM) attacks. Setting verify to False\nmay be useful during local development or testing.\ncert \u2013 (optional) if String, path to ssl client cert file (.pem).\nIf Tuple, (\u2018cert\u2019, \u2018key\u2019) pair.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.resolve_redirects",
      "title": "resolve_redirects(resp, req, stream=False, timeout=None, verify=True, cert=None, proxies=None, yield_requests=False, **adapter_kwargs)",
      "content": "Receives a Response. Returns a generator of Responses or Requests.\n"
    },
    {
      "id": "requests.Session.send",
      "title": "send(request, **kwargs)[source]",
      "content": "Send a given PreparedRequest.\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.should_strip_auth",
      "title": "should_strip_auth(old_url, new_url)",
      "content": "Decide whether Authorization header should be removed when redirecting\n"
    },
    {
      "id": "requests.Session.stream",
      "title": "stream",
      "content": "Stream response content default.\n"
    },
    {
      "id": "requests.Session.trust_env",
      "title": "trust_env",
      "content": "Trust environment settings for proxy configuration, default\nauthentication and similar.\n"
    },
    {
      "id": "requests.Session.verify",
      "title": "verify",
      "content": "SSL Verification default.\nDefaults to True, requiring requests to verify the TLS certificate at the\nremote end.\nIf verify is set to False, requests will accept any TLS certificate\npresented by the server, and will ignore hostname mismatches and/or\nexpired certificates, which will make your application vulnerable to\nman-in-the-middle (MitM) attacks.\nOnly set this to False for testing.\n"
    },
    {
      "id": "requests.Session.auth",
      "title": "auth",
      "content": "Default Authentication tuple or object to attach to\nRequest.\n"
    },
    {
      "id": "requests.Session.cert",
      "title": "cert",
      "content": "SSL client certificate default, if String, path to ssl client\ncert file (.pem). If Tuple, (\u2018cert\u2019, \u2018key\u2019) pair.\n"
    },
    {
      "id": "requests.Session.close",
      "title": "close()[source]",
      "content": "Closes all adapters and as such the session\n"
    },
    {
      "id": "requests.Session.cookies",
      "title": "cookies",
      "content": "A CookieJar containing all currently outstanding cookies set on this\nsession. By default it is a\nRequestsCookieJar, but\nmay be any other cookielib.CookieJar compatible object.\n"
    },
    {
      "id": "requests.Session.delete",
      "title": "delete(url, **kwargs)[source]",
      "content": "Sends a DELETE request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.get",
      "title": "get(url, **kwargs)[source]",
      "content": "Sends a GET request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.get_adapter",
      "title": "get_adapter(url)[source]",
      "content": "Returns the appropriate connection adapter for the given URL.\n\nReturn type\nrequests.adapters.BaseAdapter\n\n\n"
    },
    {
      "id": "requests.Session.get_redirect_target",
      "title": "get_redirect_target(resp)",
      "content": "Receives a Response. Returns a redirect URI or None\n"
    },
    {
      "id": "requests.Session.head",
      "title": "head(url, **kwargs)[source]",
      "content": "Sends a HEAD request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.headers",
      "title": "headers",
      "content": "A case-insensitive dictionary of headers to be sent on each\nRequest sent from this\nSession.\n"
    },
    {
      "id": "requests.Session.hooks",
      "title": "hooks",
      "content": "Event-handling hooks.\n"
    },
    {
      "id": "requests.Session.max_redirects",
      "title": "max_redirects",
      "content": "Maximum number of redirects allowed. If the request exceeds this\nlimit, a TooManyRedirects exception is raised.\nThis defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n30.\n"
    },
    {
      "id": "requests.Session.merge_environment_settings",
      "title": "merge_environment_settings(url, proxies, stream, verify, cert)[source]",
      "content": "Check the environment and merge it with some settings.\n\nReturn type\ndict\n\n\n"
    },
    {
      "id": "requests.Session.mount",
      "title": "mount(prefix, adapter)[source]",
      "content": "Registers a connection adapter to a prefix.\nAdapters are sorted in descending order by prefix length.\n"
    },
    {
      "id": "requests.Session.options",
      "title": "options(url, **kwargs)[source]",
      "content": "Sends a OPTIONS request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.params",
      "title": "params",
      "content": "Dictionary of querystring data to attach to each\nRequest. The dictionary values may be lists for\nrepresenting multivalued query parameters.\n"
    },
    {
      "id": "requests.Session.patch",
      "title": "patch(url, data=None, **kwargs)[source]",
      "content": "Sends a PATCH request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.post",
      "title": "post(url, data=None, json=None, **kwargs)[source]",
      "content": "Sends a POST request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\njson \u2013 (optional) json to send in the body of the Request.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.prepare_request",
      "title": "prepare_request(request)[source]",
      "content": "Constructs a PreparedRequest for\ntransmission and returns it. The PreparedRequest has settings\nmerged from the Request instance and those of the\nSession.\n\nParameters\nrequest \u2013 Request instance to prepare with this\nsession\u2019s settings.\n\nReturn type\nrequests.PreparedRequest\n\n\n"
    },
    {
      "id": "requests.Session.proxies",
      "title": "proxies",
      "content": "Dictionary mapping protocol or protocol and host to the URL of the proxy\n(e.g. {\u2018http\u2019: \u2018foo.bar:3128\u2019, \u2018http://host.name\u2019: \u2018foo.bar:4012\u2019}) to\nbe used on each Request.\n"
    },
    {
      "id": "requests.Session.put",
      "title": "put(url, data=None, **kwargs)[source]",
      "content": "Sends a PUT request. Returns Response object.\n\nParameters\n\nurl \u2013 URL for the new Request object.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\n**kwargs \u2013 Optional arguments that request takes.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.rebuild_auth",
      "title": "rebuild_auth(prepared_request, response)",
      "content": "When being redirected we may want to strip authentication from the\nrequest to avoid leaking credentials. This method intelligently removes\nand reapplies authentication where possible to avoid credential loss.\n"
    },
    {
      "id": "requests.Session.rebuild_method",
      "title": "rebuild_method(prepared_request, response)",
      "content": "When being redirected we may want to change the method of the request\nbased on certain specs or browser behavior.\n"
    },
    {
      "id": "requests.Session.rebuild_proxies",
      "title": "rebuild_proxies(prepared_request, proxies)",
      "content": "This method re-evaluates the proxy configuration by considering the\nenvironment variables. If we are redirected to a URL covered by\nNO_PROXY, we strip the proxy configuration. Otherwise, we set missing\nproxy keys for this URL (in case they were stripped by a previous\nredirect).\nThis method also replaces the Proxy-Authorization header where\nnecessary.\n\nReturn type\ndict\n\n\n"
    },
    {
      "id": "requests.Session.request",
      "title": "request(method, url, params=None, data=None, headers=None, cookies=None, files=None, auth=None, timeout=None, allow_redirects=True, proxies=None, hooks=None, stream=None, verify=None, cert=None, json=None)[source]",
      "content": "Constructs a Request, prepares it and sends it.\nReturns Response object.\n\nParameters\n\nmethod \u2013 method for the new Request object.\nurl \u2013 URL for the new Request object.\nparams \u2013 (optional) Dictionary or bytes to be sent in the query\nstring for the Request.\ndata \u2013 (optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the Request.\njson \u2013 (optional) json to send in the body of the\nRequest.\nheaders \u2013 (optional) Dictionary of HTTP Headers to send with the\nRequest.\ncookies \u2013 (optional) Dict or CookieJar object to send with the\nRequest.\nfiles \u2013 (optional) Dictionary of 'filename': file-like-objects\nfor multipart encoding upload.\nauth \u2013 (optional) Auth tuple or callable to enable\nBasic/Digest/Custom HTTP Auth.\ntimeout (float or tuple) \u2013 (optional) How long to wait for the server to send\ndata before giving up, as a float, or a (connect timeout,\nread timeout) tuple.\nallow_redirects (bool) \u2013 (optional) Set to True by default.\nproxies \u2013 (optional) Dictionary mapping protocol or protocol and\nhostname to the URL of the proxy.\nstream \u2013 (optional) whether to immediately download the response\ncontent. Defaults to False.\nverify \u2013 (optional) Either a boolean, in which case it controls whether we verify\nthe server\u2019s TLS certificate, or a string, in which case it must be a path\nto a CA bundle to use. Defaults to True. When set to\nFalse, requests will accept any TLS certificate presented by\nthe server, and will ignore hostname mismatches and/or expired\ncertificates, which will make your application vulnerable to\nman-in-the-middle (MitM) attacks. Setting verify to False\nmay be useful during local development or testing.\ncert \u2013 (optional) if String, path to ssl client cert file (.pem).\nIf Tuple, (\u2018cert\u2019, \u2018key\u2019) pair.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.resolve_redirects",
      "title": "resolve_redirects(resp, req, stream=False, timeout=None, verify=True, cert=None, proxies=None, yield_requests=False, **adapter_kwargs)",
      "content": "Receives a Response. Returns a generator of Responses or Requests.\n"
    },
    {
      "id": "requests.Session.send",
      "title": "send(request, **kwargs)[source]",
      "content": "Send a given PreparedRequest.\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.Session.should_strip_auth",
      "title": "should_strip_auth(old_url, new_url)",
      "content": "Decide whether Authorization header should be removed when redirecting\n"
    },
    {
      "id": "requests.Session.stream",
      "title": "stream",
      "content": "Stream response content default.\n"
    },
    {
      "id": "requests.Session.trust_env",
      "title": "trust_env",
      "content": "Trust environment settings for proxy configuration, default\nauthentication and similar.\n"
    },
    {
      "id": "requests.Session.verify",
      "title": "verify",
      "content": "SSL Verification default.\nDefaults to True, requiring requests to verify the TLS certificate at the\nremote end.\nIf verify is set to False, requests will accept any TLS certificate\npresented by the server, and will ignore hostname mismatches and/or\nexpired certificates, which will make your application vulnerable to\nman-in-the-middle (MitM) attacks.\nOnly set this to False for testing.\n"
    },
    {
      "id": "requests.Request",
      "title": "class requests.Request(method=None, url=None, headers=None, files=None, data=None, params=None, auth=None, cookies=None, hooks=None, json=None)[source]",
      "content": "A user-created Request object.\nUsed to prepare a PreparedRequest, which is sent to the server.\n\nParameters\n\nmethod \u2013 HTTP method to use.\nurl \u2013 URL to send.\nheaders \u2013 dictionary of headers to send.\nfiles \u2013 dictionary of {filename: fileobject} files to multipart upload.\ndata \u2013 the body to attach to the request. If a dictionary or\nlist of tuples [(key, value)] is provided, form-encoding will\ntake place.\njson \u2013 json for the body to attach to the request (if files or data is not specified).\nparams \u2013 URL parameters to append to the URL. If a dictionary or\nlist of tuples [(key, value)] is provided, form-encoding will\ntake place.\nauth \u2013 Auth handler or (user, pass) tuple.\ncookies \u2013 dictionary or CookieJar of cookies to attach to this request.\nhooks \u2013 dictionary of callback hooks, for internal usage.\n\n\n\nUsage:\n>>> import requests\n>>> req = requests.Request('GET', 'https://httpbin.org/get')\n>>> req.prepare()\n<PreparedRequest [GET]>\n\n\n\n\nderegister_hook(event, hook)\nDeregister a previously registered hook.\nReturns True if the hook existed, False if not.\n\n\n\n\nprepare()[source]\nConstructs a PreparedRequest for transmission and returns it.\n\n\n\n\nregister_hook(event, hook)\nProperly register a hook.\n\n\n"
    },
    {
      "id": "requests.Request.deregister_hook",
      "title": "deregister_hook(event, hook)",
      "content": "Deregister a previously registered hook.\nReturns True if the hook existed, False if not.\n"
    },
    {
      "id": "requests.Request.prepare",
      "title": "prepare()[source]",
      "content": "Constructs a PreparedRequest for transmission and returns it.\n"
    },
    {
      "id": "requests.Request.register_hook",
      "title": "register_hook(event, hook)",
      "content": "Properly register a hook.\n"
    },
    {
      "id": "requests.Request.deregister_hook",
      "title": "deregister_hook(event, hook)",
      "content": "Deregister a previously registered hook.\nReturns True if the hook existed, False if not.\n"
    },
    {
      "id": "requests.Request.prepare",
      "title": "prepare()[source]",
      "content": "Constructs a PreparedRequest for transmission and returns it.\n"
    },
    {
      "id": "requests.Request.register_hook",
      "title": "register_hook(event, hook)",
      "content": "Properly register a hook.\n"
    },
    {
      "id": "requests.Response",
      "title": "class requests.Response[source]",
      "content": "The Response object, which contains a\nserver\u2019s response to an HTTP request.\n\n\nproperty apparent_encoding\nThe apparent encoding, provided by the charset_normalizer or chardet libraries.\n\n\n\n\nclose()[source]\nReleases the connection back to the pool. Once this method has been\ncalled the underlying raw object must not be accessed again.\nNote: Should not normally need to be called explicitly.\n\n\n\n\nproperty content\nContent of the response, in bytes.\n\n\n\n\ncookies\nA CookieJar of Cookies the server sent back.\n\n\n\n\nelapsed\nThe amount of time elapsed between sending the request\nand the arrival of the response (as a timedelta).\nThis property specifically measures the time taken between sending\nthe first byte of the request and finishing parsing the headers. It\nis therefore unaffected by consuming the response content or the\nvalue of the stream keyword argument.\n\n\n\n\nencoding\nEncoding to decode with when accessing r.text.\n\n\n\n\nheaders\nCase-insensitive Dictionary of Response Headers.\nFor example, headers['content-encoding'] will return the\nvalue of a 'Content-Encoding' response header.\n\n\n\n\nhistory\nA list of Response objects from\nthe history of the Request. Any redirect responses will end\nup here. The list is sorted from the oldest to the most recent request.\n\n\n\n\nproperty is_permanent_redirect\nTrue if this Response one of the permanent versions of redirect.\n\n\n\n\nproperty is_redirect\nTrue if this Response is a well-formed HTTP redirect that could have\nbeen processed automatically (by Session.resolve_redirects).\n\n\n\n\niter_content(chunk_size=1, decode_unicode=False)[source]\nIterates over the response data.  When stream=True is set on the\nrequest, this avoids reading the content at once into memory for\nlarge responses.  The chunk size is the number of bytes it should\nread into memory.  This is not necessarily the length of each item\nreturned as decoding can take place.\nchunk_size must be of type int or None. A value of None will\nfunction differently depending on the value of stream.\nstream=True will read data as it arrives in whatever size the\nchunks are received. If stream=False, data is returned as\na single chunk.\nIf decode_unicode is True, content will be decoded using the best\navailable encoding based on the response.\n\n\n\n\niter_lines(chunk_size=512, decode_unicode=False, delimiter=None)[source]\nIterates over the response data, one line at a time.  When\nstream=True is set on the request, this avoids reading the\ncontent at once into memory for large responses.\n\nNote\nThis method is not reentrant safe.\n\n\n\n\n\njson(**kwargs)[source]\nReturns the json-encoded content of a response, if any.\n\nParameters\n**kwargs \u2013 Optional arguments that json.loads takes.\n\nRaises\nrequests.exceptions.JSONDecodeError \u2013 If the response body does not\ncontain valid json.\n\n\n\n\n\n\nproperty links\nReturns the parsed header links of the response, if any.\n\n\n\n\nproperty next\nReturns a PreparedRequest for the next request in a redirect chain, if there is one.\n\n\n\n\nproperty ok\nReturns True if status_code is less than 400, False if not.\nThis attribute checks if the status code of the response is between\n400 and 600 to see if there was a client error or a server error. If\nthe status code is between 200 and 400, this will return True. This\nis not a check to see if the response code is 200 OK.\n\n\n\n\nraise_for_status()[source]\nRaises HTTPError, if one occurred.\n\n\n\n\nraw\nFile-like object representation of response (for advanced usage).\nUse of raw requires that stream=True be set on the request.\nThis requirement does not apply for use internally to Requests.\n\n\n\n\nreason\nTextual reason of responded HTTP Status, e.g. \u201cNot Found\u201d or \u201cOK\u201d.\n\n\n\n\nrequest\nThe PreparedRequest object to which this\nis a response.\n\n\n\n\nstatus_code\nInteger Code of responded HTTP Status, e.g. 404 or 200.\n\n\n\n\nproperty text\nContent of the response, in unicode.\nIf Response.encoding is None, encoding will be guessed using\ncharset_normalizer or chardet.\nThe encoding of the response content is determined based solely on HTTP\nheaders, following RFC 2616 to the letter. If you can take advantage of\nnon-HTTP knowledge to make a better guess at the encoding, you should\nset r.encoding appropriately before accessing this property.\n\n\n\n\nurl\nFinal URL location of Response.\n\n\n"
    },
    {
      "id": "requests.Response.apparent_encoding",
      "title": "property apparent_encoding",
      "content": "The apparent encoding, provided by the charset_normalizer or chardet libraries.\n"
    },
    {
      "id": "requests.Response.close",
      "title": "close()[source]",
      "content": "Releases the connection back to the pool. Once this method has been\ncalled the underlying raw object must not be accessed again.\nNote: Should not normally need to be called explicitly.\n"
    },
    {
      "id": "requests.Response.content",
      "title": "property content",
      "content": "Content of the response, in bytes.\n"
    },
    {
      "id": "requests.Response.cookies",
      "title": "cookies",
      "content": "A CookieJar of Cookies the server sent back.\n"
    },
    {
      "id": "requests.Response.elapsed",
      "title": "elapsed",
      "content": "The amount of time elapsed between sending the request\nand the arrival of the response (as a timedelta).\nThis property specifically measures the time taken between sending\nthe first byte of the request and finishing parsing the headers. It\nis therefore unaffected by consuming the response content or the\nvalue of the stream keyword argument.\n"
    },
    {
      "id": "requests.Response.encoding",
      "title": "encoding",
      "content": "Encoding to decode with when accessing r.text.\n"
    },
    {
      "id": "requests.Response.headers",
      "title": "headers",
      "content": "Case-insensitive Dictionary of Response Headers.\nFor example, headers['content-encoding'] will return the\nvalue of a 'Content-Encoding' response header.\n"
    },
    {
      "id": "requests.Response.history",
      "title": "history",
      "content": "A list of Response objects from\nthe history of the Request. Any redirect responses will end\nup here. The list is sorted from the oldest to the most recent request.\n"
    },
    {
      "id": "requests.Response.is_permanent_redirect",
      "title": "property is_permanent_redirect",
      "content": "True if this Response one of the permanent versions of redirect.\n"
    },
    {
      "id": "requests.Response.is_redirect",
      "title": "property is_redirect",
      "content": "True if this Response is a well-formed HTTP redirect that could have\nbeen processed automatically (by Session.resolve_redirects).\n"
    },
    {
      "id": "requests.Response.iter_content",
      "title": "iter_content(chunk_size=1, decode_unicode=False)[source]",
      "content": "Iterates over the response data.  When stream=True is set on the\nrequest, this avoids reading the content at once into memory for\nlarge responses.  The chunk size is the number of bytes it should\nread into memory.  This is not necessarily the length of each item\nreturned as decoding can take place.\nchunk_size must be of type int or None. A value of None will\nfunction differently depending on the value of stream.\nstream=True will read data as it arrives in whatever size the\nchunks are received. If stream=False, data is returned as\na single chunk.\nIf decode_unicode is True, content will be decoded using the best\navailable encoding based on the response.\n"
    },
    {
      "id": "requests.Response.iter_lines",
      "title": "iter_lines(chunk_size=512, decode_unicode=False, delimiter=None)[source]",
      "content": "Iterates over the response data, one line at a time.  When\nstream=True is set on the request, this avoids reading the\ncontent at once into memory for large responses.\n\nNote\nThis method is not reentrant safe.\n\n"
    },
    {
      "id": "requests.Response.json",
      "title": "json(**kwargs)[source]",
      "content": "Returns the json-encoded content of a response, if any.\n\nParameters\n**kwargs \u2013 Optional arguments that json.loads takes.\n\nRaises\nrequests.exceptions.JSONDecodeError \u2013 If the response body does not\ncontain valid json.\n\n\n"
    },
    {
      "id": "requests.Response.links",
      "title": "property links",
      "content": "Returns the parsed header links of the response, if any.\n"
    },
    {
      "id": "requests.Response.next",
      "title": "property next",
      "content": "Returns a PreparedRequest for the next request in a redirect chain, if there is one.\n"
    },
    {
      "id": "requests.Response.ok",
      "title": "property ok",
      "content": "Returns True if status_code is less than 400, False if not.\nThis attribute checks if the status code of the response is between\n400 and 600 to see if there was a client error or a server error. If\nthe status code is between 200 and 400, this will return True. This\nis not a check to see if the response code is 200 OK.\n"
    },
    {
      "id": "requests.Response.raise_for_status",
      "title": "raise_for_status()[source]",
      "content": "Raises HTTPError, if one occurred.\n"
    },
    {
      "id": "requests.Response.raw",
      "title": "raw",
      "content": "File-like object representation of response (for advanced usage).\nUse of raw requires that stream=True be set on the request.\nThis requirement does not apply for use internally to Requests.\n"
    },
    {
      "id": "requests.Response.reason",
      "title": "reason",
      "content": "Textual reason of responded HTTP Status, e.g. \u201cNot Found\u201d or \u201cOK\u201d.\n"
    },
    {
      "id": "requests.Response.request",
      "title": "request",
      "content": "The PreparedRequest object to which this\nis a response.\n"
    },
    {
      "id": "requests.Response.status_code",
      "title": "status_code",
      "content": "Integer Code of responded HTTP Status, e.g. 404 or 200.\n"
    },
    {
      "id": "requests.Response.text",
      "title": "property text",
      "content": "Content of the response, in unicode.\nIf Response.encoding is None, encoding will be guessed using\ncharset_normalizer or chardet.\nThe encoding of the response content is determined based solely on HTTP\nheaders, following RFC 2616 to the letter. If you can take advantage of\nnon-HTTP knowledge to make a better guess at the encoding, you should\nset r.encoding appropriately before accessing this property.\n"
    },
    {
      "id": "requests.Response.url",
      "title": "url",
      "content": "Final URL location of Response.\n"
    },
    {
      "id": "requests.Response.apparent_encoding",
      "title": "property apparent_encoding",
      "content": "The apparent encoding, provided by the charset_normalizer or chardet libraries.\n"
    },
    {
      "id": "requests.Response.close",
      "title": "close()[source]",
      "content": "Releases the connection back to the pool. Once this method has been\ncalled the underlying raw object must not be accessed again.\nNote: Should not normally need to be called explicitly.\n"
    },
    {
      "id": "requests.Response.content",
      "title": "property content",
      "content": "Content of the response, in bytes.\n"
    },
    {
      "id": "requests.Response.cookies",
      "title": "cookies",
      "content": "A CookieJar of Cookies the server sent back.\n"
    },
    {
      "id": "requests.Response.elapsed",
      "title": "elapsed",
      "content": "The amount of time elapsed between sending the request\nand the arrival of the response (as a timedelta).\nThis property specifically measures the time taken between sending\nthe first byte of the request and finishing parsing the headers. It\nis therefore unaffected by consuming the response content or the\nvalue of the stream keyword argument.\n"
    },
    {
      "id": "requests.Response.encoding",
      "title": "encoding",
      "content": "Encoding to decode with when accessing r.text.\n"
    },
    {
      "id": "requests.Response.headers",
      "title": "headers",
      "content": "Case-insensitive Dictionary of Response Headers.\nFor example, headers['content-encoding'] will return the\nvalue of a 'Content-Encoding' response header.\n"
    },
    {
      "id": "requests.Response.history",
      "title": "history",
      "content": "A list of Response objects from\nthe history of the Request. Any redirect responses will end\nup here. The list is sorted from the oldest to the most recent request.\n"
    },
    {
      "id": "requests.Response.is_permanent_redirect",
      "title": "property is_permanent_redirect",
      "content": "True if this Response one of the permanent versions of redirect.\n"
    },
    {
      "id": "requests.Response.is_redirect",
      "title": "property is_redirect",
      "content": "True if this Response is a well-formed HTTP redirect that could have\nbeen processed automatically (by Session.resolve_redirects).\n"
    },
    {
      "id": "requests.Response.iter_content",
      "title": "iter_content(chunk_size=1, decode_unicode=False)[source]",
      "content": "Iterates over the response data.  When stream=True is set on the\nrequest, this avoids reading the content at once into memory for\nlarge responses.  The chunk size is the number of bytes it should\nread into memory.  This is not necessarily the length of each item\nreturned as decoding can take place.\nchunk_size must be of type int or None. A value of None will\nfunction differently depending on the value of stream.\nstream=True will read data as it arrives in whatever size the\nchunks are received. If stream=False, data is returned as\na single chunk.\nIf decode_unicode is True, content will be decoded using the best\navailable encoding based on the response.\n"
    },
    {
      "id": "requests.Response.iter_lines",
      "title": "iter_lines(chunk_size=512, decode_unicode=False, delimiter=None)[source]",
      "content": "Iterates over the response data, one line at a time.  When\nstream=True is set on the request, this avoids reading the\ncontent at once into memory for large responses.\n\nNote\nThis method is not reentrant safe.\n\n"
    },
    {
      "id": "requests.Response.json",
      "title": "json(**kwargs)[source]",
      "content": "Returns the json-encoded content of a response, if any.\n\nParameters\n**kwargs \u2013 Optional arguments that json.loads takes.\n\nRaises\nrequests.exceptions.JSONDecodeError \u2013 If the response body does not\ncontain valid json.\n\n\n"
    },
    {
      "id": "requests.Response.links",
      "title": "property links",
      "content": "Returns the parsed header links of the response, if any.\n"
    },
    {
      "id": "requests.Response.next",
      "title": "property next",
      "content": "Returns a PreparedRequest for the next request in a redirect chain, if there is one.\n"
    },
    {
      "id": "requests.Response.ok",
      "title": "property ok",
      "content": "Returns True if status_code is less than 400, False if not.\nThis attribute checks if the status code of the response is between\n400 and 600 to see if there was a client error or a server error. If\nthe status code is between 200 and 400, this will return True. This\nis not a check to see if the response code is 200 OK.\n"
    },
    {
      "id": "requests.Response.raise_for_status",
      "title": "raise_for_status()[source]",
      "content": "Raises HTTPError, if one occurred.\n"
    },
    {
      "id": "requests.Response.raw",
      "title": "raw",
      "content": "File-like object representation of response (for advanced usage).\nUse of raw requires that stream=True be set on the request.\nThis requirement does not apply for use internally to Requests.\n"
    },
    {
      "id": "requests.Response.reason",
      "title": "reason",
      "content": "Textual reason of responded HTTP Status, e.g. \u201cNot Found\u201d or \u201cOK\u201d.\n"
    },
    {
      "id": "requests.Response.request",
      "title": "request",
      "content": "The PreparedRequest object to which this\nis a response.\n"
    },
    {
      "id": "requests.Response.status_code",
      "title": "status_code",
      "content": "Integer Code of responded HTTP Status, e.g. 404 or 200.\n"
    },
    {
      "id": "requests.Response.text",
      "title": "property text",
      "content": "Content of the response, in unicode.\nIf Response.encoding is None, encoding will be guessed using\ncharset_normalizer or chardet.\nThe encoding of the response content is determined based solely on HTTP\nheaders, following RFC 2616 to the letter. If you can take advantage of\nnon-HTTP knowledge to make a better guess at the encoding, you should\nset r.encoding appropriately before accessing this property.\n"
    },
    {
      "id": "requests.Response.url",
      "title": "url",
      "content": "Final URL location of Response.\n"
    },
    {
      "id": "requests.PreparedRequest",
      "title": "class requests.PreparedRequest[source]",
      "content": "The fully mutable PreparedRequest object,\ncontaining the exact bytes that will be sent to the server.\nInstances are generated from a Request object, and\nshould not be instantiated manually; doing so may produce undesirable\neffects.\nUsage:\n>>> import requests\n>>> req = requests.Request('GET', 'https://httpbin.org/get')\n>>> r = req.prepare()\n>>> r\n<PreparedRequest [GET]>\n\n>>> s = requests.Session()\n>>> s.send(r)\n<Response [200]>\n\n\n\n\nbody\nrequest body to send to the server.\n\n\n\n\nderegister_hook(event, hook)\nDeregister a previously registered hook.\nReturns True if the hook existed, False if not.\n\n\n\n\nheaders\ndictionary of HTTP headers.\n\n\n\n\nhooks\ndictionary of callback hooks, for internal usage.\n\n\n\n\nmethod\nHTTP verb to send to the server.\n\n\n\n\nproperty path_url\nBuild the path URL to use.\n\n\n\n\nprepare(method=None, url=None, headers=None, files=None, data=None, params=None, auth=None, cookies=None, hooks=None, json=None)[source]\nPrepares the entire request with the given parameters.\n\n\n\n\nprepare_auth(auth, url='')[source]\nPrepares the given HTTP auth data.\n\n\n\n\nprepare_body(data, files, json=None)[source]\nPrepares the given HTTP body data.\n\n\n\n\nprepare_content_length(body)[source]\nPrepare Content-Length header based on request method and body\n\n\n\n\nprepare_cookies(cookies)[source]\nPrepares the given HTTP cookie data.\nThis function eventually generates a Cookie header from the\ngiven cookies using cookielib. Due to cookielib\u2019s design, the header\nwill not be regenerated if it already exists, meaning this function\ncan only be called once for the life of the\nPreparedRequest object. Any subsequent calls\nto prepare_cookies will have no actual effect, unless the \u201cCookie\u201d\nheader is removed beforehand.\n\n\n\n\nprepare_headers(headers)[source]\nPrepares the given HTTP headers.\n\n\n\n\nprepare_hooks(hooks)[source]\nPrepares the given hooks.\n\n\n\n\nprepare_method(method)[source]\nPrepares the given HTTP method.\n\n\n\n\nprepare_url(url, params)[source]\nPrepares the given HTTP URL.\n\n\n\n\nregister_hook(event, hook)\nProperly register a hook.\n\n\n\n\nurl\nHTTP URL to send the request to.\n\n\n"
    },
    {
      "id": "requests.PreparedRequest.body",
      "title": "body",
      "content": "request body to send to the server.\n"
    },
    {
      "id": "requests.PreparedRequest.deregister_hook",
      "title": "deregister_hook(event, hook)",
      "content": "Deregister a previously registered hook.\nReturns True if the hook existed, False if not.\n"
    },
    {
      "id": "requests.PreparedRequest.headers",
      "title": "headers",
      "content": "dictionary of HTTP headers.\n"
    },
    {
      "id": "requests.PreparedRequest.hooks",
      "title": "hooks",
      "content": "dictionary of callback hooks, for internal usage.\n"
    },
    {
      "id": "requests.PreparedRequest.method",
      "title": "method",
      "content": "HTTP verb to send to the server.\n"
    },
    {
      "id": "requests.PreparedRequest.path_url",
      "title": "property path_url",
      "content": "Build the path URL to use.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare",
      "title": "prepare(method=None, url=None, headers=None, files=None, data=None, params=None, auth=None, cookies=None, hooks=None, json=None)[source]",
      "content": "Prepares the entire request with the given parameters.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_auth",
      "title": "prepare_auth(auth, url='')[source]",
      "content": "Prepares the given HTTP auth data.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_body",
      "title": "prepare_body(data, files, json=None)[source]",
      "content": "Prepares the given HTTP body data.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_content_length",
      "title": "prepare_content_length(body)[source]",
      "content": "Prepare Content-Length header based on request method and body\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_cookies",
      "title": "prepare_cookies(cookies)[source]",
      "content": "Prepares the given HTTP cookie data.\nThis function eventually generates a Cookie header from the\ngiven cookies using cookielib. Due to cookielib\u2019s design, the header\nwill not be regenerated if it already exists, meaning this function\ncan only be called once for the life of the\nPreparedRequest object. Any subsequent calls\nto prepare_cookies will have no actual effect, unless the \u201cCookie\u201d\nheader is removed beforehand.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_headers",
      "title": "prepare_headers(headers)[source]",
      "content": "Prepares the given HTTP headers.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_hooks",
      "title": "prepare_hooks(hooks)[source]",
      "content": "Prepares the given hooks.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_method",
      "title": "prepare_method(method)[source]",
      "content": "Prepares the given HTTP method.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_url",
      "title": "prepare_url(url, params)[source]",
      "content": "Prepares the given HTTP URL.\n"
    },
    {
      "id": "requests.PreparedRequest.register_hook",
      "title": "register_hook(event, hook)",
      "content": "Properly register a hook.\n"
    },
    {
      "id": "requests.PreparedRequest.url",
      "title": "url",
      "content": "HTTP URL to send the request to.\n"
    },
    {
      "id": "requests.PreparedRequest.body",
      "title": "body",
      "content": "request body to send to the server.\n"
    },
    {
      "id": "requests.PreparedRequest.deregister_hook",
      "title": "deregister_hook(event, hook)",
      "content": "Deregister a previously registered hook.\nReturns True if the hook existed, False if not.\n"
    },
    {
      "id": "requests.PreparedRequest.headers",
      "title": "headers",
      "content": "dictionary of HTTP headers.\n"
    },
    {
      "id": "requests.PreparedRequest.hooks",
      "title": "hooks",
      "content": "dictionary of callback hooks, for internal usage.\n"
    },
    {
      "id": "requests.PreparedRequest.method",
      "title": "method",
      "content": "HTTP verb to send to the server.\n"
    },
    {
      "id": "requests.PreparedRequest.path_url",
      "title": "property path_url",
      "content": "Build the path URL to use.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare",
      "title": "prepare(method=None, url=None, headers=None, files=None, data=None, params=None, auth=None, cookies=None, hooks=None, json=None)[source]",
      "content": "Prepares the entire request with the given parameters.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_auth",
      "title": "prepare_auth(auth, url='')[source]",
      "content": "Prepares the given HTTP auth data.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_body",
      "title": "prepare_body(data, files, json=None)[source]",
      "content": "Prepares the given HTTP body data.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_content_length",
      "title": "prepare_content_length(body)[source]",
      "content": "Prepare Content-Length header based on request method and body\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_cookies",
      "title": "prepare_cookies(cookies)[source]",
      "content": "Prepares the given HTTP cookie data.\nThis function eventually generates a Cookie header from the\ngiven cookies using cookielib. Due to cookielib\u2019s design, the header\nwill not be regenerated if it already exists, meaning this function\ncan only be called once for the life of the\nPreparedRequest object. Any subsequent calls\nto prepare_cookies will have no actual effect, unless the \u201cCookie\u201d\nheader is removed beforehand.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_headers",
      "title": "prepare_headers(headers)[source]",
      "content": "Prepares the given HTTP headers.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_hooks",
      "title": "prepare_hooks(hooks)[source]",
      "content": "Prepares the given hooks.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_method",
      "title": "prepare_method(method)[source]",
      "content": "Prepares the given HTTP method.\n"
    },
    {
      "id": "requests.PreparedRequest.prepare_url",
      "title": "prepare_url(url, params)[source]",
      "content": "Prepares the given HTTP URL.\n"
    },
    {
      "id": "requests.PreparedRequest.register_hook",
      "title": "register_hook(event, hook)",
      "content": "Properly register a hook.\n"
    },
    {
      "id": "requests.PreparedRequest.url",
      "title": "url",
      "content": "HTTP URL to send the request to.\n"
    },
    {
      "id": "requests.adapters.BaseAdapter",
      "title": "class requests.adapters.BaseAdapter[source]",
      "content": "The Base Transport Adapter\n\n\nclose()[source]\nCleans up adapter specific items.\n\n\n\n\nsend(request, stream=False, timeout=None, verify=True, cert=None, proxies=None)[source]\nSends PreparedRequest object. Returns Response object.\n\nParameters\n\nrequest \u2013 The PreparedRequest being sent.\nstream \u2013 (optional) Whether to stream the request content.\ntimeout (float or tuple) \u2013 (optional) How long to wait for the server to send\ndata before giving up, as a float, or a (connect timeout,\nread timeout) tuple.\nverify \u2013 (optional) Either a boolean, in which case it controls whether we verify\nthe server\u2019s TLS certificate, or a string, in which case it must be a path\nto a CA bundle to use\ncert \u2013 (optional) Any user-provided SSL certificate to be trusted.\nproxies \u2013 (optional) The proxies dictionary to apply to the request.\n\n\n\n\n\n"
    },
    {
      "id": "requests.adapters.BaseAdapter.close",
      "title": "close()[source]",
      "content": "Cleans up adapter specific items.\n"
    },
    {
      "id": "requests.adapters.BaseAdapter.send",
      "title": "send(request, stream=False, timeout=None, verify=True, cert=None, proxies=None)[source]",
      "content": "Sends PreparedRequest object. Returns Response object.\n\nParameters\n\nrequest \u2013 The PreparedRequest being sent.\nstream \u2013 (optional) Whether to stream the request content.\ntimeout (float or tuple) \u2013 (optional) How long to wait for the server to send\ndata before giving up, as a float, or a (connect timeout,\nread timeout) tuple.\nverify \u2013 (optional) Either a boolean, in which case it controls whether we verify\nthe server\u2019s TLS certificate, or a string, in which case it must be a path\nto a CA bundle to use\ncert \u2013 (optional) Any user-provided SSL certificate to be trusted.\nproxies \u2013 (optional) The proxies dictionary to apply to the request.\n\n\n\n"
    },
    {
      "id": "requests.adapters.BaseAdapter.close",
      "title": "close()[source]",
      "content": "Cleans up adapter specific items.\n"
    },
    {
      "id": "requests.adapters.BaseAdapter.send",
      "title": "send(request, stream=False, timeout=None, verify=True, cert=None, proxies=None)[source]",
      "content": "Sends PreparedRequest object. Returns Response object.\n\nParameters\n\nrequest \u2013 The PreparedRequest being sent.\nstream \u2013 (optional) Whether to stream the request content.\ntimeout (float or tuple) \u2013 (optional) How long to wait for the server to send\ndata before giving up, as a float, or a (connect timeout,\nread timeout) tuple.\nverify \u2013 (optional) Either a boolean, in which case it controls whether we verify\nthe server\u2019s TLS certificate, or a string, in which case it must be a path\nto a CA bundle to use\ncert \u2013 (optional) Any user-provided SSL certificate to be trusted.\nproxies \u2013 (optional) The proxies dictionary to apply to the request.\n\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter",
      "title": "class requests.adapters.HTTPAdapter(pool_connections=10, pool_maxsize=10, max_retries=0, pool_block=False)[source]",
      "content": "The built-in HTTP Adapter for urllib3.\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the Session class under the\ncovers.\n\nParameters\n\npool_connections \u2013 The number of urllib3 connection pools to cache.\npool_maxsize \u2013 The maximum number of connections to save in the pool.\nmax_retries \u2013 The maximum number of retries each connection\nshould attempt. Note, this applies only to failed DNS lookups, socket\nconnections and connection timeouts, never to requests where data has\nmade it to the server. By default, Requests does not retry failed\nconnections. If you need granular control over the conditions under\nwhich we retry a request, import urllib3\u2019s Retry class and pass\nthat instead.\npool_block \u2013 Whether the connection pool should block for connections.\n\n\n\nUsage:\n>>> import requests\n>>> s = requests.Session()\n>>> a = requests.adapters.HTTPAdapter(max_retries=3)\n>>> s.mount('http://', a)\n\n\n\n\nadd_headers(request, **kwargs)[source]\nAdd any headers needed by the connection. As of v2.0 this does\nnothing by default, but is left for overriding by users that subclass\nthe HTTPAdapter.\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\nHTTPAdapter.\n\nParameters\n\nrequest \u2013 The PreparedRequest to add headers to.\nkwargs \u2013 The keyword arguments from the call to send().\n\n\n\n\n\n\n\nbuild_response(req, resp)[source]\nBuilds a Response object from a urllib3\nresponse. This should not be called from user code, and is only exposed\nfor use when subclassing the\nHTTPAdapter\n\nParameters\n\nreq \u2013 The PreparedRequest used to generate the response.\nresp \u2013 The urllib3 response object.\n\n\nReturn type\nrequests.Response\n\n\n\n\n\n\ncert_verify(conn, url, verify, cert)[source]\nVerify a SSL certificate. This method should not be called from user\ncode, and is only exposed for use when subclassing the\nHTTPAdapter.\n\nParameters\n\nconn \u2013 The urllib3 connection object associated with the cert.\nurl \u2013 The requested URL.\nverify \u2013 Either a boolean, in which case it controls whether we verify\nthe server\u2019s TLS certificate, or a string, in which case it must be a path\nto a CA bundle to use\ncert \u2013 The SSL certificate to verify.\n\n\n\n\n\n\n\nclose()[source]\nDisposes of any internal state.\nCurrently, this closes the PoolManager and any active ProxyManager,\nwhich closes any pooled connections.\n\n\n\n\nget_connection(url, proxies=None)[source]\nReturns a urllib3 connection for the given URL. This should not be\ncalled from user code, and is only exposed for use when subclassing the\nHTTPAdapter.\n\nParameters\n\nurl \u2013 The URL to connect to.\nproxies \u2013 (optional) A Requests-style dictionary of proxies used on this request.\n\n\nReturn type\nurllib3.ConnectionPool\n\n\n\n\n\n\ninit_poolmanager(connections, maxsize, block=False, **pool_kwargs)[source]\nInitializes a urllib3 PoolManager.\nThis method should not be called from user code, and is only\nexposed for use when subclassing the\nHTTPAdapter.\n\nParameters\n\nconnections \u2013 The number of urllib3 connection pools to cache.\nmaxsize \u2013 The maximum number of connections to save in the pool.\nblock \u2013 Block when no free connections are available.\npool_kwargs \u2013 Extra keyword arguments used to initialize the Pool Manager.\n\n\n\n\n\n\n\nproxy_headers(proxy)[source]\nReturns a dictionary of the headers to add to any request sent\nthrough a proxy. This works with urllib3 magic to ensure that they are\ncorrectly sent to the proxy, rather than in a tunnelled request if\nCONNECT is being used.\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\nHTTPAdapter.\n\nParameters\nproxy \u2013 The url of the proxy being used for this request.\n\nReturn type\ndict\n\n\n\n\n\n\nproxy_manager_for(proxy, **proxy_kwargs)[source]\nReturn urllib3 ProxyManager for the given proxy.\nThis method should not be called from user code, and is only\nexposed for use when subclassing the\nHTTPAdapter.\n\nParameters\n\nproxy \u2013 The proxy to return a urllib3 ProxyManager for.\nproxy_kwargs \u2013 Extra keyword arguments used to configure the Proxy Manager.\n\n\nReturns\nProxyManager\n\nReturn type\nurllib3.ProxyManager\n\n\n\n\n\n\nrequest_url(request, proxies)[source]\nObtain the url to use when making the final request.\nIf the message is being sent through a HTTP proxy, the full URL has to\nbe used. Otherwise, we should only use the path portion of the URL.\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\nHTTPAdapter.\n\nParameters\n\nrequest \u2013 The PreparedRequest being sent.\nproxies \u2013 A dictionary of schemes or schemes and hosts to proxy URLs.\n\n\nReturn type\nstr\n\n\n\n\n\n\nsend(request, stream=False, timeout=None, verify=True, cert=None, proxies=None)[source]\nSends PreparedRequest object. Returns Response object.\n\nParameters\n\nrequest \u2013 The PreparedRequest being sent.\nstream \u2013 (optional) Whether to stream the request content.\ntimeout (float or tuple or urllib3 Timeout object) \u2013 (optional) How long to wait for the server to send\ndata before giving up, as a float, or a (connect timeout,\nread timeout) tuple.\nverify \u2013 (optional) Either a boolean, in which case it controls whether\nwe verify the server\u2019s TLS certificate, or a string, in which case it\nmust be a path to a CA bundle to use\ncert \u2013 (optional) Any user-provided SSL certificate to be trusted.\nproxies \u2013 (optional) The proxies dictionary to apply to the request.\n\n\nReturn type\nrequests.Response\n\n\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.add_headers",
      "title": "add_headers(request, **kwargs)[source]",
      "content": "Add any headers needed by the connection. As of v2.0 this does\nnothing by default, but is left for overriding by users that subclass\nthe HTTPAdapter.\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\nHTTPAdapter.\n\nParameters\n\nrequest \u2013 The PreparedRequest to add headers to.\nkwargs \u2013 The keyword arguments from the call to send().\n\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.build_response",
      "title": "build_response(req, resp)[source]",
      "content": "Builds a Response object from a urllib3\nresponse. This should not be called from user code, and is only exposed\nfor use when subclassing the\nHTTPAdapter\n\nParameters\n\nreq \u2013 The PreparedRequest used to generate the response.\nresp \u2013 The urllib3 response object.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.cert_verify",
      "title": "cert_verify(conn, url, verify, cert)[source]",
      "content": "Verify a SSL certificate. This method should not be called from user\ncode, and is only exposed for use when subclassing the\nHTTPAdapter.\n\nParameters\n\nconn \u2013 The urllib3 connection object associated with the cert.\nurl \u2013 The requested URL.\nverify \u2013 Either a boolean, in which case it controls whether we verify\nthe server\u2019s TLS certificate, or a string, in which case it must be a path\nto a CA bundle to use\ncert \u2013 The SSL certificate to verify.\n\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.close",
      "title": "close()[source]",
      "content": "Disposes of any internal state.\nCurrently, this closes the PoolManager and any active ProxyManager,\nwhich closes any pooled connections.\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.get_connection",
      "title": "get_connection(url, proxies=None)[source]",
      "content": "Returns a urllib3 connection for the given URL. This should not be\ncalled from user code, and is only exposed for use when subclassing the\nHTTPAdapter.\n\nParameters\n\nurl \u2013 The URL to connect to.\nproxies \u2013 (optional) A Requests-style dictionary of proxies used on this request.\n\n\nReturn type\nurllib3.ConnectionPool\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.init_poolmanager",
      "title": "init_poolmanager(connections, maxsize, block=False, **pool_kwargs)[source]",
      "content": "Initializes a urllib3 PoolManager.\nThis method should not be called from user code, and is only\nexposed for use when subclassing the\nHTTPAdapter.\n\nParameters\n\nconnections \u2013 The number of urllib3 connection pools to cache.\nmaxsize \u2013 The maximum number of connections to save in the pool.\nblock \u2013 Block when no free connections are available.\npool_kwargs \u2013 Extra keyword arguments used to initialize the Pool Manager.\n\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.proxy_headers",
      "title": "proxy_headers(proxy)[source]",
      "content": "Returns a dictionary of the headers to add to any request sent\nthrough a proxy. This works with urllib3 magic to ensure that they are\ncorrectly sent to the proxy, rather than in a tunnelled request if\nCONNECT is being used.\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\nHTTPAdapter.\n\nParameters\nproxy \u2013 The url of the proxy being used for this request.\n\nReturn type\ndict\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.proxy_manager_for",
      "title": "proxy_manager_for(proxy, **proxy_kwargs)[source]",
      "content": "Return urllib3 ProxyManager for the given proxy.\nThis method should not be called from user code, and is only\nexposed for use when subclassing the\nHTTPAdapter.\n\nParameters\n\nproxy \u2013 The proxy to return a urllib3 ProxyManager for.\nproxy_kwargs \u2013 Extra keyword arguments used to configure the Proxy Manager.\n\n\nReturns\nProxyManager\n\nReturn type\nurllib3.ProxyManager\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.request_url",
      "title": "request_url(request, proxies)[source]",
      "content": "Obtain the url to use when making the final request.\nIf the message is being sent through a HTTP proxy, the full URL has to\nbe used. Otherwise, we should only use the path portion of the URL.\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\nHTTPAdapter.\n\nParameters\n\nrequest \u2013 The PreparedRequest being sent.\nproxies \u2013 A dictionary of schemes or schemes and hosts to proxy URLs.\n\n\nReturn type\nstr\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.send",
      "title": "send(request, stream=False, timeout=None, verify=True, cert=None, proxies=None)[source]",
      "content": "Sends PreparedRequest object. Returns Response object.\n\nParameters\n\nrequest \u2013 The PreparedRequest being sent.\nstream \u2013 (optional) Whether to stream the request content.\ntimeout (float or tuple or urllib3 Timeout object) \u2013 (optional) How long to wait for the server to send\ndata before giving up, as a float, or a (connect timeout,\nread timeout) tuple.\nverify \u2013 (optional) Either a boolean, in which case it controls whether\nwe verify the server\u2019s TLS certificate, or a string, in which case it\nmust be a path to a CA bundle to use\ncert \u2013 (optional) Any user-provided SSL certificate to be trusted.\nproxies \u2013 (optional) The proxies dictionary to apply to the request.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.add_headers",
      "title": "add_headers(request, **kwargs)[source]",
      "content": "Add any headers needed by the connection. As of v2.0 this does\nnothing by default, but is left for overriding by users that subclass\nthe HTTPAdapter.\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\nHTTPAdapter.\n\nParameters\n\nrequest \u2013 The PreparedRequest to add headers to.\nkwargs \u2013 The keyword arguments from the call to send().\n\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.build_response",
      "title": "build_response(req, resp)[source]",
      "content": "Builds a Response object from a urllib3\nresponse. This should not be called from user code, and is only exposed\nfor use when subclassing the\nHTTPAdapter\n\nParameters\n\nreq \u2013 The PreparedRequest used to generate the response.\nresp \u2013 The urllib3 response object.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.cert_verify",
      "title": "cert_verify(conn, url, verify, cert)[source]",
      "content": "Verify a SSL certificate. This method should not be called from user\ncode, and is only exposed for use when subclassing the\nHTTPAdapter.\n\nParameters\n\nconn \u2013 The urllib3 connection object associated with the cert.\nurl \u2013 The requested URL.\nverify \u2013 Either a boolean, in which case it controls whether we verify\nthe server\u2019s TLS certificate, or a string, in which case it must be a path\nto a CA bundle to use\ncert \u2013 The SSL certificate to verify.\n\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.close",
      "title": "close()[source]",
      "content": "Disposes of any internal state.\nCurrently, this closes the PoolManager and any active ProxyManager,\nwhich closes any pooled connections.\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.get_connection",
      "title": "get_connection(url, proxies=None)[source]",
      "content": "Returns a urllib3 connection for the given URL. This should not be\ncalled from user code, and is only exposed for use when subclassing the\nHTTPAdapter.\n\nParameters\n\nurl \u2013 The URL to connect to.\nproxies \u2013 (optional) A Requests-style dictionary of proxies used on this request.\n\n\nReturn type\nurllib3.ConnectionPool\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.init_poolmanager",
      "title": "init_poolmanager(connections, maxsize, block=False, **pool_kwargs)[source]",
      "content": "Initializes a urllib3 PoolManager.\nThis method should not be called from user code, and is only\nexposed for use when subclassing the\nHTTPAdapter.\n\nParameters\n\nconnections \u2013 The number of urllib3 connection pools to cache.\nmaxsize \u2013 The maximum number of connections to save in the pool.\nblock \u2013 Block when no free connections are available.\npool_kwargs \u2013 Extra keyword arguments used to initialize the Pool Manager.\n\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.proxy_headers",
      "title": "proxy_headers(proxy)[source]",
      "content": "Returns a dictionary of the headers to add to any request sent\nthrough a proxy. This works with urllib3 magic to ensure that they are\ncorrectly sent to the proxy, rather than in a tunnelled request if\nCONNECT is being used.\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\nHTTPAdapter.\n\nParameters\nproxy \u2013 The url of the proxy being used for this request.\n\nReturn type\ndict\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.proxy_manager_for",
      "title": "proxy_manager_for(proxy, **proxy_kwargs)[source]",
      "content": "Return urllib3 ProxyManager for the given proxy.\nThis method should not be called from user code, and is only\nexposed for use when subclassing the\nHTTPAdapter.\n\nParameters\n\nproxy \u2013 The proxy to return a urllib3 ProxyManager for.\nproxy_kwargs \u2013 Extra keyword arguments used to configure the Proxy Manager.\n\n\nReturns\nProxyManager\n\nReturn type\nurllib3.ProxyManager\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.request_url",
      "title": "request_url(request, proxies)[source]",
      "content": "Obtain the url to use when making the final request.\nIf the message is being sent through a HTTP proxy, the full URL has to\nbe used. Otherwise, we should only use the path portion of the URL.\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\nHTTPAdapter.\n\nParameters\n\nrequest \u2013 The PreparedRequest being sent.\nproxies \u2013 A dictionary of schemes or schemes and hosts to proxy URLs.\n\n\nReturn type\nstr\n\n\n"
    },
    {
      "id": "requests.adapters.HTTPAdapter.send",
      "title": "send(request, stream=False, timeout=None, verify=True, cert=None, proxies=None)[source]",
      "content": "Sends PreparedRequest object. Returns Response object.\n\nParameters\n\nrequest \u2013 The PreparedRequest being sent.\nstream \u2013 (optional) Whether to stream the request content.\ntimeout (float or tuple or urllib3 Timeout object) \u2013 (optional) How long to wait for the server to send\ndata before giving up, as a float, or a (connect timeout,\nread timeout) tuple.\nverify \u2013 (optional) Either a boolean, in which case it controls whether\nwe verify the server\u2019s TLS certificate, or a string, in which case it\nmust be a path to a CA bundle to use\ncert \u2013 (optional) Any user-provided SSL certificate to be trusted.\nproxies \u2013 (optional) The proxies dictionary to apply to the request.\n\n\nReturn type\nrequests.Response\n\n\n"
    },
    {
      "id": "requests.auth.AuthBase",
      "title": "class requests.auth.AuthBase[source]",
      "content": "Base class that all auth implementations derive from\n"
    },
    {
      "id": "requests.auth.HTTPBasicAuth",
      "title": "class requests.auth.HTTPBasicAuth(username, password)[source]",
      "content": "Attaches HTTP Basic Authentication to the given Request object.\n"
    },
    {
      "id": "requests.auth.HTTPProxyAuth",
      "title": "class requests.auth.HTTPProxyAuth(username, password)[source]",
      "content": "Attaches HTTP Proxy Authentication to a given Request object.\n"
    },
    {
      "id": "requests.auth.HTTPDigestAuth",
      "title": "class requests.auth.HTTPDigestAuth(username, password)[source]",
      "content": "Attaches HTTP Digest Authentication to the given Request object.\n"
    },
    {
      "id": "requests.utils.get_encodings_from_content",
      "title": "requests.utils.get_encodings_from_content(content)[source]",
      "content": "Returns encodings from given content string.\n\nParameters\ncontent \u2013 bytestring to extract encodings from.\n\n\n"
    },
    {
      "id": "requests.utils.get_encoding_from_headers",
      "title": "requests.utils.get_encoding_from_headers(headers)[source]",
      "content": "Returns encodings from given HTTP Header Dict.\n\nParameters\nheaders \u2013 dictionary to extract encoding from.\n\nReturn type\nstr\n\n\n"
    },
    {
      "id": "requests.utils.get_unicode_from_response",
      "title": "requests.utils.get_unicode_from_response(r)[source]",
      "content": "Returns the requested content back in unicode.\n\nParameters\nr \u2013 Response object to get unicode content from.\n\n\nTried:\n\ncharset from content-type\nfall back and replace all unicode characters\n\n\nReturn type\nstr\n\n\n"
    },
    {
      "id": "requests.utils.dict_from_cookiejar",
      "title": "requests.utils.dict_from_cookiejar(cj)[source]",
      "content": "Returns a key/value dictionary from a CookieJar.\n\nParameters\ncj \u2013 CookieJar object to extract cookies from.\n\nReturn type\ndict\n\n\n"
    },
    {
      "id": "requests.utils.add_dict_to_cookiejar",
      "title": "requests.utils.add_dict_to_cookiejar(cj, cookie_dict)[source]",
      "content": "Returns a CookieJar from a key/value dictionary.\n\nParameters\n\ncj \u2013 CookieJar to insert cookies into.\ncookie_dict \u2013 Dict of key/values to insert into CookieJar.\n\n\nReturn type\nCookieJar\n\n\n"
    },
    {
      "id": "requests.cookies.cookiejar_from_dict",
      "title": "requests.cookies.cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True)[source]",
      "content": "Returns a CookieJar from a key/value dictionary.\n\nParameters\n\ncookie_dict \u2013 Dict of key/values to insert into CookieJar.\ncookiejar \u2013 (optional) A cookiejar to add the cookies to.\noverwrite \u2013 (optional) If False, will not replace cookies\nalready in the jar with new ones.\n\n\nReturn type\nCookieJar\n\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar",
      "title": "class requests.cookies.RequestsCookieJar(policy=None)[source]",
      "content": "Compatibility class; is a cookielib.CookieJar, but exposes a dict\ninterface.\nThis is the CookieJar we create by default for requests and sessions that\ndon\u2019t specify one, since some clients may expect response.cookies and\nsession.cookies to support dict operations.\nRequests does not use the dict interface internally; it\u2019s just for\ncompatibility with external client code. All requests code should work\nout of the box with externally provided instances of CookieJar, e.g.\nLWPCookieJar and FileCookieJar.\nUnlike a regular CookieJar, this class is pickleable.\n\nWarning\ndictionary operations that are normally O(1) may be O(n).\n\n\n\nadd_cookie_header(request)\nAdd correct Cookie: header to request (urllib.request.Request object).\nThe Cookie2 header is also added unless policy.hide_cookie2 is true.\n\n\n\n\nclear(domain=None, path=None, name=None)\nClear some cookies.\nInvoking this method without arguments will clear all cookies.  If\ngiven a single argument, only cookies belonging to that domain will be\nremoved.  If given two arguments, cookies belonging to the specified\npath within that domain are removed.  If given three arguments, then\nthe cookie with the specified name, path and domain is removed.\nRaises KeyError if no matching cookie exists.\n\n\n\n\nclear_expired_cookies()\nDiscard all expired cookies.\nYou probably don\u2019t need to call this method: expired cookies are never\nsent back to the server (provided you\u2019re using DefaultCookiePolicy),\nthis method is called by CookieJar itself every so often, and the\n.save() method won\u2019t save expired cookies anyway (unless you ask\notherwise by passing a true ignore_expires argument).\n\n\n\n\nclear_session_cookies()\nDiscard all session cookies.\nNote that the .save() method won\u2019t save session cookies anyway, unless\nyou ask otherwise by passing a true ignore_discard argument.\n\n\n\n\ncopy()[source]\nReturn a copy of this RequestsCookieJar.\n\n\n\n\nextract_cookies(response, request)\nExtract cookies from response, where allowable given the request.\n\n\n\n\nget(name, default=None, domain=None, path=None)[source]\nDict-like get() that also supports optional domain and path args in\norder to resolve naming collisions from using one cookie jar over\nmultiple domains.\n\nWarning\noperation is O(n), not O(1).\n\n\n\n\n\nget_dict(domain=None, path=None)[source]\nTakes as an argument an optional domain and path and returns a plain\nold Python dict of name-value pairs of cookies that meet the\nrequirements.\n\nReturn type\ndict\n\n\n\n\n\n\nget_policy()[source]\nReturn the CookiePolicy instance used.\n\n\n\n\nitems()[source]\nDict-like items() that returns a list of name-value tuples from the\njar. Allows client-code to call dict(RequestsCookieJar) and get a\nvanilla python dict of key value pairs.\n\nSee also\nkeys() and values().\n\n\n\n\n\niteritems()[source]\nDict-like iteritems() that returns an iterator of name-value tuples\nfrom the jar.\n\nSee also\niterkeys() and itervalues().\n\n\n\n\n\niterkeys()[source]\nDict-like iterkeys() that returns an iterator of names of cookies\nfrom the jar.\n\nSee also\nitervalues() and iteritems().\n\n\n\n\n\nitervalues()[source]\nDict-like itervalues() that returns an iterator of values of cookies\nfrom the jar.\n\nSee also\niterkeys() and iteritems().\n\n\n\n\n\nkeys()[source]\nDict-like keys() that returns a list of names of cookies from the\njar.\n\nSee also\nvalues() and items().\n\n\n\n\n\nlist_domains()[source]\nUtility method to list all the domains in the jar.\n\n\n\n\nlist_paths()[source]\nUtility method to list all the paths in the jar.\n\n\n\n\nmake_cookies(response, request)\nReturn sequence of Cookie objects extracted from response object.\n\n\n\n\nmultiple_domains()[source]\nReturns True if there are multiple domains in the jar.\nReturns False otherwise.\n\nReturn type\nbool\n\n\n\n\n\n\npop(k[, d]) \u2192 v, remove specified key and return the corresponding value.\nIf key is not found, d is returned if given, otherwise KeyError is raised.\n\n\n\n\npopitem() \u2192 (k, v), remove and return some (key, value) pair\nas a 2-tuple; but raise KeyError if D is empty.\n\n\n\n\nset(name, value, **kwargs)[source]\nDict-like set() that also supports optional domain and path args in\norder to resolve naming collisions from using one cookie jar over\nmultiple domains.\n\n\n\n\nset_cookie(cookie, *args, **kwargs)[source]\nSet a cookie, without checking whether or not it should be set.\n\n\n\n\nset_cookie_if_ok(cookie, request)\nSet a cookie if policy says it\u2019s OK to do so.\n\n\n\n\nsetdefault(k[, d]) \u2192 D.get(k,d), also set D[k]=d if k not in D\n\n\n\n\nupdate(other)[source]\nUpdates this jar with cookies from another CookieJar or dict-like\n\n\n\n\nvalues()[source]\nDict-like values() that returns a list of values of cookies from the\njar.\n\nSee also\nkeys() and items().\n\n\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.add_cookie_header",
      "title": "add_cookie_header(request)",
      "content": "Add correct Cookie: header to request (urllib.request.Request object).\nThe Cookie2 header is also added unless policy.hide_cookie2 is true.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.clear",
      "title": "clear(domain=None, path=None, name=None)",
      "content": "Clear some cookies.\nInvoking this method without arguments will clear all cookies.  If\ngiven a single argument, only cookies belonging to that domain will be\nremoved.  If given two arguments, cookies belonging to the specified\npath within that domain are removed.  If given three arguments, then\nthe cookie with the specified name, path and domain is removed.\nRaises KeyError if no matching cookie exists.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.clear_expired_cookies",
      "title": "clear_expired_cookies()",
      "content": "Discard all expired cookies.\nYou probably don\u2019t need to call this method: expired cookies are never\nsent back to the server (provided you\u2019re using DefaultCookiePolicy),\nthis method is called by CookieJar itself every so often, and the\n.save() method won\u2019t save expired cookies anyway (unless you ask\notherwise by passing a true ignore_expires argument).\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.clear_session_cookies",
      "title": "clear_session_cookies()",
      "content": "Discard all session cookies.\nNote that the .save() method won\u2019t save session cookies anyway, unless\nyou ask otherwise by passing a true ignore_discard argument.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.copy",
      "title": "copy()[source]",
      "content": "Return a copy of this RequestsCookieJar.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.extract_cookies",
      "title": "extract_cookies(response, request)",
      "content": "Extract cookies from response, where allowable given the request.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.get",
      "title": "get(name, default=None, domain=None, path=None)[source]",
      "content": "Dict-like get() that also supports optional domain and path args in\norder to resolve naming collisions from using one cookie jar over\nmultiple domains.\n\nWarning\noperation is O(n), not O(1).\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.get_dict",
      "title": "get_dict(domain=None, path=None)[source]",
      "content": "Takes as an argument an optional domain and path and returns a plain\nold Python dict of name-value pairs of cookies that meet the\nrequirements.\n\nReturn type\ndict\n\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.get_policy",
      "title": "get_policy()[source]",
      "content": "Return the CookiePolicy instance used.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.items",
      "title": "items()[source]",
      "content": "Dict-like items() that returns a list of name-value tuples from the\njar. Allows client-code to call dict(RequestsCookieJar) and get a\nvanilla python dict of key value pairs.\n\nSee also\nkeys() and values().\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.iteritems",
      "title": "iteritems()[source]",
      "content": "Dict-like iteritems() that returns an iterator of name-value tuples\nfrom the jar.\n\nSee also\niterkeys() and itervalues().\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.iterkeys",
      "title": "iterkeys()[source]",
      "content": "Dict-like iterkeys() that returns an iterator of names of cookies\nfrom the jar.\n\nSee also\nitervalues() and iteritems().\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.itervalues",
      "title": "itervalues()[source]",
      "content": "Dict-like itervalues() that returns an iterator of values of cookies\nfrom the jar.\n\nSee also\niterkeys() and iteritems().\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.keys",
      "title": "keys()[source]",
      "content": "Dict-like keys() that returns a list of names of cookies from the\njar.\n\nSee also\nvalues() and items().\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.list_domains",
      "title": "list_domains()[source]",
      "content": "Utility method to list all the domains in the jar.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.list_paths",
      "title": "list_paths()[source]",
      "content": "Utility method to list all the paths in the jar.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.make_cookies",
      "title": "make_cookies(response, request)",
      "content": "Return sequence of Cookie objects extracted from response object.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.multiple_domains",
      "title": "multiple_domains()[source]",
      "content": "Returns True if there are multiple domains in the jar.\nReturns False otherwise.\n\nReturn type\nbool\n\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.pop",
      "title": "pop(k[, d]) \u2192 v, remove specified key and return the corresponding value.",
      "content": "If key is not found, d is returned if given, otherwise KeyError is raised.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.popitem",
      "title": "popitem() \u2192 (k, v), remove and return some (key, value) pair",
      "content": "as a 2-tuple; but raise KeyError if D is empty.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.set",
      "title": "set(name, value, **kwargs)[source]",
      "content": "Dict-like set() that also supports optional domain and path args in\norder to resolve naming collisions from using one cookie jar over\nmultiple domains.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.set_cookie",
      "title": "set_cookie(cookie, *args, **kwargs)[source]",
      "content": "Set a cookie, without checking whether or not it should be set.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.set_cookie_if_ok",
      "title": "set_cookie_if_ok(cookie, request)",
      "content": "Set a cookie if policy says it\u2019s OK to do so.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.setdefault",
      "title": "setdefault(k[, d]) \u2192 D.get(k,d), also set D[k]=d if k not in D",
      "content": ""
    },
    {
      "id": "requests.cookies.RequestsCookieJar.update",
      "title": "update(other)[source]",
      "content": "Updates this jar with cookies from another CookieJar or dict-like\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.values",
      "title": "values()[source]",
      "content": "Dict-like values() that returns a list of values of cookies from the\njar.\n\nSee also\nkeys() and items().\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.add_cookie_header",
      "title": "add_cookie_header(request)",
      "content": "Add correct Cookie: header to request (urllib.request.Request object).\nThe Cookie2 header is also added unless policy.hide_cookie2 is true.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.clear",
      "title": "clear(domain=None, path=None, name=None)",
      "content": "Clear some cookies.\nInvoking this method without arguments will clear all cookies.  If\ngiven a single argument, only cookies belonging to that domain will be\nremoved.  If given two arguments, cookies belonging to the specified\npath within that domain are removed.  If given three arguments, then\nthe cookie with the specified name, path and domain is removed.\nRaises KeyError if no matching cookie exists.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.clear_expired_cookies",
      "title": "clear_expired_cookies()",
      "content": "Discard all expired cookies.\nYou probably don\u2019t need to call this method: expired cookies are never\nsent back to the server (provided you\u2019re using DefaultCookiePolicy),\nthis method is called by CookieJar itself every so often, and the\n.save() method won\u2019t save expired cookies anyway (unless you ask\notherwise by passing a true ignore_expires argument).\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.clear_session_cookies",
      "title": "clear_session_cookies()",
      "content": "Discard all session cookies.\nNote that the .save() method won\u2019t save session cookies anyway, unless\nyou ask otherwise by passing a true ignore_discard argument.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.copy",
      "title": "copy()[source]",
      "content": "Return a copy of this RequestsCookieJar.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.extract_cookies",
      "title": "extract_cookies(response, request)",
      "content": "Extract cookies from response, where allowable given the request.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.get",
      "title": "get(name, default=None, domain=None, path=None)[source]",
      "content": "Dict-like get() that also supports optional domain and path args in\norder to resolve naming collisions from using one cookie jar over\nmultiple domains.\n\nWarning\noperation is O(n), not O(1).\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.get_dict",
      "title": "get_dict(domain=None, path=None)[source]",
      "content": "Takes as an argument an optional domain and path and returns a plain\nold Python dict of name-value pairs of cookies that meet the\nrequirements.\n\nReturn type\ndict\n\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.get_policy",
      "title": "get_policy()[source]",
      "content": "Return the CookiePolicy instance used.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.items",
      "title": "items()[source]",
      "content": "Dict-like items() that returns a list of name-value tuples from the\njar. Allows client-code to call dict(RequestsCookieJar) and get a\nvanilla python dict of key value pairs.\n\nSee also\nkeys() and values().\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.iteritems",
      "title": "iteritems()[source]",
      "content": "Dict-like iteritems() that returns an iterator of name-value tuples\nfrom the jar.\n\nSee also\niterkeys() and itervalues().\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.iterkeys",
      "title": "iterkeys()[source]",
      "content": "Dict-like iterkeys() that returns an iterator of names of cookies\nfrom the jar.\n\nSee also\nitervalues() and iteritems().\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.itervalues",
      "title": "itervalues()[source]",
      "content": "Dict-like itervalues() that returns an iterator of values of cookies\nfrom the jar.\n\nSee also\niterkeys() and iteritems().\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.keys",
      "title": "keys()[source]",
      "content": "Dict-like keys() that returns a list of names of cookies from the\njar.\n\nSee also\nvalues() and items().\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.list_domains",
      "title": "list_domains()[source]",
      "content": "Utility method to list all the domains in the jar.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.list_paths",
      "title": "list_paths()[source]",
      "content": "Utility method to list all the paths in the jar.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.make_cookies",
      "title": "make_cookies(response, request)",
      "content": "Return sequence of Cookie objects extracted from response object.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.multiple_domains",
      "title": "multiple_domains()[source]",
      "content": "Returns True if there are multiple domains in the jar.\nReturns False otherwise.\n\nReturn type\nbool\n\n\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.pop",
      "title": "pop(k[, d]) \u2192 v, remove specified key and return the corresponding value.",
      "content": "If key is not found, d is returned if given, otherwise KeyError is raised.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.popitem",
      "title": "popitem() \u2192 (k, v), remove and return some (key, value) pair",
      "content": "as a 2-tuple; but raise KeyError if D is empty.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.set",
      "title": "set(name, value, **kwargs)[source]",
      "content": "Dict-like set() that also supports optional domain and path args in\norder to resolve naming collisions from using one cookie jar over\nmultiple domains.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.set_cookie",
      "title": "set_cookie(cookie, *args, **kwargs)[source]",
      "content": "Set a cookie, without checking whether or not it should be set.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.set_cookie_if_ok",
      "title": "set_cookie_if_ok(cookie, request)",
      "content": "Set a cookie if policy says it\u2019s OK to do so.\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.setdefault",
      "title": "setdefault(k[, d]) \u2192 D.get(k,d), also set D[k]=d if k not in D",
      "content": ""
    },
    {
      "id": "requests.cookies.RequestsCookieJar.update",
      "title": "update(other)[source]",
      "content": "Updates this jar with cookies from another CookieJar or dict-like\n"
    },
    {
      "id": "requests.cookies.RequestsCookieJar.values",
      "title": "values()[source]",
      "content": "Dict-like values() that returns a list of values of cookies from the\njar.\n\nSee also\nkeys() and items().\n\n"
    },
    {
      "id": "requests.cookies.CookieConflictError",
      "title": "class requests.cookies.CookieConflictError[source]",
      "content": "There are two cookies that meet the criteria specified in the cookie jar.\nUse .get and .set and include domain and path args in order to be more specific.\n\n\nwith_traceback()\nException.with_traceback(tb) \u2013\nset self.__traceback__ to tb and return self.\n\n\n"
    },
    {
      "id": "requests.cookies.CookieConflictError.with_traceback",
      "title": "with_traceback()",
      "content": "Exception.with_traceback(tb) \u2013\nset self.__traceback__ to tb and return self.\n"
    },
    {
      "id": "requests.cookies.CookieConflictError.with_traceback",
      "title": "with_traceback()",
      "content": "Exception.with_traceback(tb) \u2013\nset self.__traceback__ to tb and return self.\n"
    },
    {
      "id": "requests.codes",
      "title": "requests.codes",
      "content": "alias of <lookup \u2018status_codes\u2019>\n"
    },
    {
      "id": "module-requests",
      "title": "Developer Interface",
      "content": "This part of the documentation covers all the interfaces of Requests. For parts where Requests depends on external libraries, we document the most important right here and provide links to the canonical documentation."
    },
    {
      "id": "main-interface",
      "title": "Main Interface",
      "content": "All of Requests\u2019 functionality can be accessed by these 7 methods. They all return an instance of the Response object."
    },
    {
      "id": "exceptions",
      "title": "Exceptions",
      "content": ""
    },
    {
      "id": "request-sessions",
      "title": "Request Sessions",
      "content": ""
    },
    {
      "id": "lower-level-classes",
      "title": "Lower-Level Classes",
      "content": ""
    },
    {
      "id": "lower-lower-level-classes",
      "title": "Lower-Lower-Level Classes",
      "content": ""
    },
    {
      "id": "authentication",
      "title": "Authentication",
      "content": ""
    },
    {
      "id": "encodings",
      "title": "Encodings",
      "content": ""
    },
    {
      "id": "cookies",
      "title": "Cookies",
      "content": ""
    },
    {
      "id": "status-code-lookup",
      "title": "Status Code Lookup",
      "content": "The codes object defines a mapping from common names for HTTP statuses to their numerical codes, accessible either as attributes or as dictionary items. Example: >>> import requests >>> requests.codes['temporary_redirect'] 307 >>> requests.codes.teapot 418 >>> requests.codes['\\o/'] 200 Some codes have multiple names, and both upper- and lower-case versions of the names are allowed. For example, codes.ok, codes.OK, and codes.okay all correspond to the HTTP status code 200. 100: continue 101: switching_protocols 102: processing 103: checkpoint 122: uri_too_long, request_uri_too_long 200: ok, okay, all_ok, all_okay, all_good, \\o/, \u2713 201: created 202: accepted 203: non_authoritative_info, non_authoritative_information 204: no_content 205: reset_content, reset 206: partial_content, partial 207: multi_status, multiple_status, multi_stati, multiple_stati 208: already_reported 226: im_used 300: multiple_choices 301: moved_permanently, moved, \\o- 302: found 303: see_other, other 304: not_modified 305: use_proxy 306: switch_proxy 307: temporary_redirect, temporary_moved, temporary 308: permanent_redirect, resume_incomplete, resume 400: bad_request, bad 401: unauthorized 402: payment_required, payment 403: forbidden 404: not_found, -o- 405: method_not_allowed, not_allowed 406: not_acceptable 407: proxy_authentication_required, proxy_auth, proxy_authentication 408: request_timeout, timeout 409: conflict 410: gone 411: length_required 412: precondition_failed, precondition 413: request_entity_too_large 414: request_uri_too_large 415: unsupported_media_type, unsupported_media, media_type 416: requested_range_not_satisfiable, requested_range, range_not_satisfiable 417: expectation_failed 418: im_a_teapot, teapot, i_am_a_teapot 421: misdirected_request 422: unprocessable_entity, unprocessable 423: locked 424: failed_dependency, dependency 425: unordered_collection, unordered 426: upgrade_required, upgrade 428: precondition_required, precondition 429: too_many_requests, too_many 431: header_fields_too_large, fields_too_large 444: no_response, none 449: retry_with, retry 450: blocked_by_windows_parental_controls, parental_controls 451: unavailable_for_legal_reasons, legal_reasons 499: client_closed_request 500: internal_server_error, server_error, /o\\, \u2717 501: not_implemented 502: bad_gateway 503: service_unavailable, unavailable 504: gateway_timeout 505: http_version_not_supported, http_version 506: variant_also_negotiates 507: insufficient_storage 509: bandwidth_limit_exceeded, bandwidth 510: not_extended 511: network_authentication_required, network_auth, network_authentication"
    },
    {
      "id": "migrating-to-1-x",
      "title": "Migrating to 1.x",
      "content": "This section details the main differences between 0.x and 1.x and is meant to ease the pain of upgrading."
    },
    {
      "id": "migrating-to-2-x",
      "title": "Migrating to 2.x",
      "content": "Compared with the 1.0 release, there were relatively few backwards incompatible changes, but there are still a few issues to be aware of with this major release. For more details on the changes in this release including new APIs, links to the relevant GitHub issues and some of the bug fixes, read Cory\u2019s blog on the subject."
    },
    {
      "id": "api-changes",
      "title": "API Changes",
      "content": "Response.json is now a callable and not a property of a response. import requests r = requests.get('https://api.github.com/events') r.json() # This *call* raises an exception if JSON decoding fails The Session API has changed. Sessions objects no longer take parameters. Session is also now capitalized, but it can still be instantiated with a lowercase session for backwards compatibility. s = requests.Session() # formerly, session took parameters s.auth = auth s.headers.update(headers) r = s.get('https://httpbin.org/headers') All request hooks have been removed except \u2018response\u2019. Authentication helpers have been broken out into separate modules. See requests-oauthlib and requests-kerberos. The parameter for streaming requests was changed from prefetch to stream and the logic was inverted. In addition, stream is now required for raw response reading. # in 0.x, passing prefetch=False would accomplish the same thing r = requests.get('https://api.github.com/events', stream=True) for chunk in r.iter_content(8192): ... The config parameter to the requests method has been removed. Some of these options are now configured on a Session such as keep-alive and maximum number of redirects. The verbosity option should be handled by configuring logging. import requests import logging # Enabling debugging at http.client level (requests->urllib3->http.client) # you will see the REQUEST, including HEADERS and DATA, and RESPONSE with HEADERS but without DATA. # the only thing missing will be the response.body which is not logged. try: # for Python 3 from http.client import HTTPConnection except ImportError: from httplib import HTTPConnection HTTPConnection.debuglevel = 1 logging.basicConfig() # you need to initialize logging, otherwise you will not see anything from requests logging.getLogger().setLevel(logging.DEBUG) requests_log = logging.getLogger(\"urllib3\") requests_log.setLevel(logging.DEBUG) requests_log.propagate = True requests.get('https://httpbin.org/headers')"
    },
    {
      "id": "licensing",
      "title": "Licensing",
      "content": "One key difference that has nothing to do with the API is a change in the license from the ISC license to the Apache 2.0 license. The Apache 2.0 license ensures that contributions to Requests are also covered by the Apache 2.0 license."
    },
    {
      "id": "id1",
      "title": "API Changes",
      "content": "There were a couple changes to how Requests handles exceptions. RequestException is now a subclass of IOError rather than RuntimeError as that more accurately categorizes the type of error. In addition, an invalid URL escape sequence now raises a subclass of RequestException rather than a ValueError. requests.get('http://%zz/') # raises requests.exceptions.InvalidURL Lastly, httplib.IncompleteRead exceptions caused by incorrect chunked encoding will now raise a Requests ChunkedEncodingError instead. The proxy API has changed slightly. The scheme for a proxy URL is now required. proxies = { \"http\": \"10.10.1.10:3128\", # use http://10.10.1.10:3128 instead } # In requests 1.x, this was legal, in requests 2.x, # this raises requests.exceptions.MissingSchema requests.get(\"http://example.org\", proxies=proxies)"
    },
    {
      "id": "behavioural-changes",
      "title": "Behavioural Changes",
      "content": "Keys in the headers dictionary are now native strings on all Python versions, i.e. bytestrings on Python 2 and unicode on Python 3. If the keys are not native strings (unicode on Python 2 or bytestrings on Python 3) they will be converted to the native string type assuming UTF-8 encoding. Values in the headers dictionary should always be strings. This has been the project\u2019s position since before 1.0 but a recent change (since version 2.11.0) enforces this more strictly. It\u2019s advised to avoid passing header values as unicode when possible."
    }
  ],
  "domain_data": {}
}
