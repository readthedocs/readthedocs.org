{
  "path": "",
  "title": "",
  "sections": [
    {
      "id": "directive-automodule",
      "title": ".. automodule::",
      "content": "Document a module, class or exception.  All three directives will by default\nonly insert the docstring of the object itself:\n.. autoclass:: Noodle\n\n\nwill produce source like this:\n.. class:: Noodle\n\n   Noodle's docstring.\n\n\nThe \u201cauto\u201d directives can also contain content of their own, it will be\ninserted into the resulting non-auto directive source after the docstring\n(but before any automatic member documentation).\nTherefore, you can also mix automatic and non-automatic member documentation,\nlike so:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n   .. method:: boil(time=10)\n\n      Boil the noodle *time* minutes.\n\n\nOptions\n\n\n:members: (no value or comma separated list)\nIf set, autodoc will generate document for the members of the target\nmodule, class or exception.\nFor example:\n.. automodule:: noodle\n   :members:\n\n\nwill document all module members (recursively), and\n.. autoclass:: Noodle\n   :members:\n\n\nwill document all class member methods and properties.\nBy default, autodoc will not generate document for the members that are\nprivate, not having docstrings, inherited from super class, or special\nmembers.\nFor modules, __all__ will be respected when looking for members unless\nyou give the ignore-module-all flag option.  Without\nignore-module-all, the order of the members will also be the order in\n__all__.\nYou can also give an explicit list of members; only these will then be\ndocumented:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n\n\n\n\n\n:undoc-members: (no value)\nIf set, autodoc will also generate document for the members not having\ndocstrings:\n.. automodule:: noodle\n   :members:\n   :undoc-members:\n\n\n\n\n\n\n:private-members: (no value or comma separated list)\nIf set, autodoc will also generate document for the private members\n(that is, those named like _private or __private):\n.. automodule:: noodle\n   :members:\n   :private-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. automodule:: noodle\n   :members:\n   :private-members: _spicy, _garlickly\n\n\n\nNew in version 1.1.\n\n\nChanged in version 3.2: The option can now take arguments.\n\n\n\n\n\n:special-members: (no value or comma separated list)\nIf set, autodoc will also generate document for the special members\n(that is, those named like __special__):\n.. autoclass:: my.Class\n   :members:\n   :special-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. autoclass:: my.Class\n   :members:\n   :special-members: __init__, __name__\n\n\n\nNew in version 1.1.\n\n\nChanged in version 1.2: The option can now take arguments\n\n\n\nOptions and advanced usage\n\nIf you want to make the members option (or other options described\nbelow) the default, see autodoc_default_options.\n\nTip\nYou can use a negated form, 'no-flag', as an option of\nautodoc directive, to disable it temporarily.  For example:\n.. automodule:: foo\n   :no-undoc-members:\n\n\n\n\nTip\nYou can use autodoc directive options to temporarily override or\nextend default options which takes list as an input. For example:\n.. autoclass:: Noodle\n   :members: eat\n   :private-members: +_spicy, _garlickly\n\n\n\n\nChanged in version 3.5: The default options can be overridden or extended temporarily.\n\n\nautodoc considers a member private if its docstring contains\n:meta private: in its Info field lists.\nFor example:\ndef my_function(my_arg, my_other_arg):\n    \"\"\"blah blah blah\n\n    :meta private:\n    \"\"\"\n\n\n\nNew in version 3.0.\n\n\nautodoc considers a member public if its docstring contains\n:meta public: in its Info field lists, even if it starts with\nan underscore.\nFor example:\ndef _my_function(my_arg, my_other_arg):\n    \"\"\"blah blah blah\n\n    :meta public:\n    \"\"\"\n\n\n\nNew in version 3.1.\n\n\nautodoc considers a variable member does not have any default value if its\ndocstring contains :meta hide-value: in its Info field lists.\nExample:\nvar1 = None  #: :meta hide-value:\n\n\n\nNew in version 3.5.\n\n\nFor classes and exceptions, members inherited from base classes will be\nleft out when documenting all members, unless you give the\ninherited-members option, in addition to members:\n.. autoclass:: Noodle\n   :members:\n   :inherited-members:\n\n\nThis can be combined with undoc-members to document all available\nmembers of the class or module.\nIt can take an ancestor class not to document inherited members from it.\nBy default, members of object class are not documented.  To show them\nall, give None to the option.\nFor example; If your class Foo is derived from list class and\nyou don\u2019t want to document list.__len__(), you should specify a\noption :inherited-members: list to avoid special members of list\nclass.\nAnother example; If your class Foo has __str__ special method and\nautodoc directive has both inherited-members and special-members,\n__str__ will be documented as in the past, but other special method\nthat are not implemented in your class Foo.\nSince v5.0, it can take a comma separated list of ancestor classes.  It\nallows to suppress inherited members of several classes on the module at\nonce by specifying the option to automodule directive.\nNote: this will lead to markup errors if the inherited members come from a\nmodule whose docstrings are not reST formatted.\n\nNew in version 0.3.\n\n\nChanged in version 3.0: It takes an ancestor class name as an argument.\n\n\nChanged in version 5.0: It takes a comma separated list of ancestor class names.\n\n\nIt\u2019s possible to override the signature for explicitly documented callable\nobjects (functions, methods, classes) with the regular syntax that will\noverride the signature gained from introspection:\n.. autoclass:: Noodle(type)\n\n   .. automethod:: eat(persona)\n\n\nThis is useful if the signature from the method is hidden by a decorator.\n\nNew in version 0.4.\n\n\nThe automodule, autoclass and\nautoexception directives also support a flag option called\nshow-inheritance.  When given, a list of base classes will be inserted\njust below the class signature (when used with automodule, this\nwill be inserted for every class that is documented in the module).\n\nNew in version 0.4.\n\n\nAll autodoc directives support the noindex flag option that has the\nsame effect as for standard py:function etc. directives: no\nindex entries are generated for the documented object (and all\nautodocumented members).\n\nNew in version 0.4.\n\n\nautomodule also recognizes the synopsis, platform and\ndeprecated options that the standard py:module directive\nsupports.\n\nNew in version 0.5.\n\n\nautomodule and autoclass also has an member-order\noption that can be used to override the global value of\nautodoc_member_order for one directive.\n\nNew in version 0.6.\n\n\nThe directives supporting member documentation also have a\nexclude-members option that can be used to exclude single member names\nfrom documentation, if all members are to be documented.\n\nNew in version 0.6.\n\n\nIn an automodule directive with the members option set, only\nmodule members whose __module__ attribute is equal to the module name\nas given to automodule will be documented.  This is to prevent\ndocumentation of imported classes or functions.  Set the\nimported-members option if you want to prevent this behavior and\ndocument all available members.  Note that attributes from imported modules\nwill not be documented, because attribute documentation is discovered by\nparsing the source file of the current module.\n\nNew in version 1.2.\n\n\nAdd a list of modules in the autodoc_mock_imports to prevent\nimport errors to halt the building process when some external dependencies\nare not importable at build time.\n\nNew in version 1.3.\n\n\nAs a hint to autodoc extension, you can put a :: separator in between\nmodule name and object name to let autodoc know the correct module name if\nit is ambiguous.\n.. autoclass:: module.name::Noodle\n\n\n\nautoclass also recognizes the class-doc-from option that\ncan be used to override the global value of autoclass_content.\n\nNew in version 4.1.\n\n\n\n"
    },
    {
      "id": "directive-autoclass",
      "title": ".. autoclass::",
      "content": "Document a module, class or exception.  All three directives will by default\nonly insert the docstring of the object itself:\n.. autoclass:: Noodle\n\n\nwill produce source like this:\n.. class:: Noodle\n\n   Noodle's docstring.\n\n\nThe \u201cauto\u201d directives can also contain content of their own, it will be\ninserted into the resulting non-auto directive source after the docstring\n(but before any automatic member documentation).\nTherefore, you can also mix automatic and non-automatic member documentation,\nlike so:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n   .. method:: boil(time=10)\n\n      Boil the noodle *time* minutes.\n\n\nOptions\n\n\n:members: (no value or comma separated list)\nIf set, autodoc will generate document for the members of the target\nmodule, class or exception.\nFor example:\n.. automodule:: noodle\n   :members:\n\n\nwill document all module members (recursively), and\n.. autoclass:: Noodle\n   :members:\n\n\nwill document all class member methods and properties.\nBy default, autodoc will not generate document for the members that are\nprivate, not having docstrings, inherited from super class, or special\nmembers.\nFor modules, __all__ will be respected when looking for members unless\nyou give the ignore-module-all flag option.  Without\nignore-module-all, the order of the members will also be the order in\n__all__.\nYou can also give an explicit list of members; only these will then be\ndocumented:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n\n\n\n\n\n:undoc-members: (no value)\nIf set, autodoc will also generate document for the members not having\ndocstrings:\n.. automodule:: noodle\n   :members:\n   :undoc-members:\n\n\n\n\n\n\n:private-members: (no value or comma separated list)\nIf set, autodoc will also generate document for the private members\n(that is, those named like _private or __private):\n.. automodule:: noodle\n   :members:\n   :private-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. automodule:: noodle\n   :members:\n   :private-members: _spicy, _garlickly\n\n\n\nNew in version 1.1.\n\n\nChanged in version 3.2: The option can now take arguments.\n\n\n\n\n\n:special-members: (no value or comma separated list)\nIf set, autodoc will also generate document for the special members\n(that is, those named like __special__):\n.. autoclass:: my.Class\n   :members:\n   :special-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. autoclass:: my.Class\n   :members:\n   :special-members: __init__, __name__\n\n\n\nNew in version 1.1.\n\n\nChanged in version 1.2: The option can now take arguments\n\n\n\nOptions and advanced usage\n\nIf you want to make the members option (or other options described\nbelow) the default, see autodoc_default_options.\n\nTip\nYou can use a negated form, 'no-flag', as an option of\nautodoc directive, to disable it temporarily.  For example:\n.. automodule:: foo\n   :no-undoc-members:\n\n\n\n\nTip\nYou can use autodoc directive options to temporarily override or\nextend default options which takes list as an input. For example:\n.. autoclass:: Noodle\n   :members: eat\n   :private-members: +_spicy, _garlickly\n\n\n\n\nChanged in version 3.5: The default options can be overridden or extended temporarily.\n\n\nautodoc considers a member private if its docstring contains\n:meta private: in its Info field lists.\nFor example:\ndef my_function(my_arg, my_other_arg):\n    \"\"\"blah blah blah\n\n    :meta private:\n    \"\"\"\n\n\n\nNew in version 3.0.\n\n\nautodoc considers a member public if its docstring contains\n:meta public: in its Info field lists, even if it starts with\nan underscore.\nFor example:\ndef _my_function(my_arg, my_other_arg):\n    \"\"\"blah blah blah\n\n    :meta public:\n    \"\"\"\n\n\n\nNew in version 3.1.\n\n\nautodoc considers a variable member does not have any default value if its\ndocstring contains :meta hide-value: in its Info field lists.\nExample:\nvar1 = None  #: :meta hide-value:\n\n\n\nNew in version 3.5.\n\n\nFor classes and exceptions, members inherited from base classes will be\nleft out when documenting all members, unless you give the\ninherited-members option, in addition to members:\n.. autoclass:: Noodle\n   :members:\n   :inherited-members:\n\n\nThis can be combined with undoc-members to document all available\nmembers of the class or module.\nIt can take an ancestor class not to document inherited members from it.\nBy default, members of object class are not documented.  To show them\nall, give None to the option.\nFor example; If your class Foo is derived from list class and\nyou don\u2019t want to document list.__len__(), you should specify a\noption :inherited-members: list to avoid special members of list\nclass.\nAnother example; If your class Foo has __str__ special method and\nautodoc directive has both inherited-members and special-members,\n__str__ will be documented as in the past, but other special method\nthat are not implemented in your class Foo.\nSince v5.0, it can take a comma separated list of ancestor classes.  It\nallows to suppress inherited members of several classes on the module at\nonce by specifying the option to automodule directive.\nNote: this will lead to markup errors if the inherited members come from a\nmodule whose docstrings are not reST formatted.\n\nNew in version 0.3.\n\n\nChanged in version 3.0: It takes an ancestor class name as an argument.\n\n\nChanged in version 5.0: It takes a comma separated list of ancestor class names.\n\n\nIt\u2019s possible to override the signature for explicitly documented callable\nobjects (functions, methods, classes) with the regular syntax that will\noverride the signature gained from introspection:\n.. autoclass:: Noodle(type)\n\n   .. automethod:: eat(persona)\n\n\nThis is useful if the signature from the method is hidden by a decorator.\n\nNew in version 0.4.\n\n\nThe automodule, autoclass and\nautoexception directives also support a flag option called\nshow-inheritance.  When given, a list of base classes will be inserted\njust below the class signature (when used with automodule, this\nwill be inserted for every class that is documented in the module).\n\nNew in version 0.4.\n\n\nAll autodoc directives support the noindex flag option that has the\nsame effect as for standard py:function etc. directives: no\nindex entries are generated for the documented object (and all\nautodocumented members).\n\nNew in version 0.4.\n\n\nautomodule also recognizes the synopsis, platform and\ndeprecated options that the standard py:module directive\nsupports.\n\nNew in version 0.5.\n\n\nautomodule and autoclass also has an member-order\noption that can be used to override the global value of\nautodoc_member_order for one directive.\n\nNew in version 0.6.\n\n\nThe directives supporting member documentation also have a\nexclude-members option that can be used to exclude single member names\nfrom documentation, if all members are to be documented.\n\nNew in version 0.6.\n\n\nIn an automodule directive with the members option set, only\nmodule members whose __module__ attribute is equal to the module name\nas given to automodule will be documented.  This is to prevent\ndocumentation of imported classes or functions.  Set the\nimported-members option if you want to prevent this behavior and\ndocument all available members.  Note that attributes from imported modules\nwill not be documented, because attribute documentation is discovered by\nparsing the source file of the current module.\n\nNew in version 1.2.\n\n\nAdd a list of modules in the autodoc_mock_imports to prevent\nimport errors to halt the building process when some external dependencies\nare not importable at build time.\n\nNew in version 1.3.\n\n\nAs a hint to autodoc extension, you can put a :: separator in between\nmodule name and object name to let autodoc know the correct module name if\nit is ambiguous.\n.. autoclass:: module.name::Noodle\n\n\n\nautoclass also recognizes the class-doc-from option that\ncan be used to override the global value of autoclass_content.\n\nNew in version 4.1.\n\n\n\n"
    },
    {
      "id": "directive-autoexception",
      "title": ".. autoexception::",
      "content": "Document a module, class or exception.  All three directives will by default\nonly insert the docstring of the object itself:\n.. autoclass:: Noodle\n\n\nwill produce source like this:\n.. class:: Noodle\n\n   Noodle's docstring.\n\n\nThe \u201cauto\u201d directives can also contain content of their own, it will be\ninserted into the resulting non-auto directive source after the docstring\n(but before any automatic member documentation).\nTherefore, you can also mix automatic and non-automatic member documentation,\nlike so:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n   .. method:: boil(time=10)\n\n      Boil the noodle *time* minutes.\n\n\nOptions\n\n\n:members: (no value or comma separated list)\nIf set, autodoc will generate document for the members of the target\nmodule, class or exception.\nFor example:\n.. automodule:: noodle\n   :members:\n\n\nwill document all module members (recursively), and\n.. autoclass:: Noodle\n   :members:\n\n\nwill document all class member methods and properties.\nBy default, autodoc will not generate document for the members that are\nprivate, not having docstrings, inherited from super class, or special\nmembers.\nFor modules, __all__ will be respected when looking for members unless\nyou give the ignore-module-all flag option.  Without\nignore-module-all, the order of the members will also be the order in\n__all__.\nYou can also give an explicit list of members; only these will then be\ndocumented:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n\n\n\n\n\n:undoc-members: (no value)\nIf set, autodoc will also generate document for the members not having\ndocstrings:\n.. automodule:: noodle\n   :members:\n   :undoc-members:\n\n\n\n\n\n\n:private-members: (no value or comma separated list)\nIf set, autodoc will also generate document for the private members\n(that is, those named like _private or __private):\n.. automodule:: noodle\n   :members:\n   :private-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. automodule:: noodle\n   :members:\n   :private-members: _spicy, _garlickly\n\n\n\nNew in version 1.1.\n\n\nChanged in version 3.2: The option can now take arguments.\n\n\n\n\n\n:special-members: (no value or comma separated list)\nIf set, autodoc will also generate document for the special members\n(that is, those named like __special__):\n.. autoclass:: my.Class\n   :members:\n   :special-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. autoclass:: my.Class\n   :members:\n   :special-members: __init__, __name__\n\n\n\nNew in version 1.1.\n\n\nChanged in version 1.2: The option can now take arguments\n\n\n\nOptions and advanced usage\n\nIf you want to make the members option (or other options described\nbelow) the default, see autodoc_default_options.\n\nTip\nYou can use a negated form, 'no-flag', as an option of\nautodoc directive, to disable it temporarily.  For example:\n.. automodule:: foo\n   :no-undoc-members:\n\n\n\n\nTip\nYou can use autodoc directive options to temporarily override or\nextend default options which takes list as an input. For example:\n.. autoclass:: Noodle\n   :members: eat\n   :private-members: +_spicy, _garlickly\n\n\n\n\nChanged in version 3.5: The default options can be overridden or extended temporarily.\n\n\nautodoc considers a member private if its docstring contains\n:meta private: in its Info field lists.\nFor example:\ndef my_function(my_arg, my_other_arg):\n    \"\"\"blah blah blah\n\n    :meta private:\n    \"\"\"\n\n\n\nNew in version 3.0.\n\n\nautodoc considers a member public if its docstring contains\n:meta public: in its Info field lists, even if it starts with\nan underscore.\nFor example:\ndef _my_function(my_arg, my_other_arg):\n    \"\"\"blah blah blah\n\n    :meta public:\n    \"\"\"\n\n\n\nNew in version 3.1.\n\n\nautodoc considers a variable member does not have any default value if its\ndocstring contains :meta hide-value: in its Info field lists.\nExample:\nvar1 = None  #: :meta hide-value:\n\n\n\nNew in version 3.5.\n\n\nFor classes and exceptions, members inherited from base classes will be\nleft out when documenting all members, unless you give the\ninherited-members option, in addition to members:\n.. autoclass:: Noodle\n   :members:\n   :inherited-members:\n\n\nThis can be combined with undoc-members to document all available\nmembers of the class or module.\nIt can take an ancestor class not to document inherited members from it.\nBy default, members of object class are not documented.  To show them\nall, give None to the option.\nFor example; If your class Foo is derived from list class and\nyou don\u2019t want to document list.__len__(), you should specify a\noption :inherited-members: list to avoid special members of list\nclass.\nAnother example; If your class Foo has __str__ special method and\nautodoc directive has both inherited-members and special-members,\n__str__ will be documented as in the past, but other special method\nthat are not implemented in your class Foo.\nSince v5.0, it can take a comma separated list of ancestor classes.  It\nallows to suppress inherited members of several classes on the module at\nonce by specifying the option to automodule directive.\nNote: this will lead to markup errors if the inherited members come from a\nmodule whose docstrings are not reST formatted.\n\nNew in version 0.3.\n\n\nChanged in version 3.0: It takes an ancestor class name as an argument.\n\n\nChanged in version 5.0: It takes a comma separated list of ancestor class names.\n\n\nIt\u2019s possible to override the signature for explicitly documented callable\nobjects (functions, methods, classes) with the regular syntax that will\noverride the signature gained from introspection:\n.. autoclass:: Noodle(type)\n\n   .. automethod:: eat(persona)\n\n\nThis is useful if the signature from the method is hidden by a decorator.\n\nNew in version 0.4.\n\n\nThe automodule, autoclass and\nautoexception directives also support a flag option called\nshow-inheritance.  When given, a list of base classes will be inserted\njust below the class signature (when used with automodule, this\nwill be inserted for every class that is documented in the module).\n\nNew in version 0.4.\n\n\nAll autodoc directives support the noindex flag option that has the\nsame effect as for standard py:function etc. directives: no\nindex entries are generated for the documented object (and all\nautodocumented members).\n\nNew in version 0.4.\n\n\nautomodule also recognizes the synopsis, platform and\ndeprecated options that the standard py:module directive\nsupports.\n\nNew in version 0.5.\n\n\nautomodule and autoclass also has an member-order\noption that can be used to override the global value of\nautodoc_member_order for one directive.\n\nNew in version 0.6.\n\n\nThe directives supporting member documentation also have a\nexclude-members option that can be used to exclude single member names\nfrom documentation, if all members are to be documented.\n\nNew in version 0.6.\n\n\nIn an automodule directive with the members option set, only\nmodule members whose __module__ attribute is equal to the module name\nas given to automodule will be documented.  This is to prevent\ndocumentation of imported classes or functions.  Set the\nimported-members option if you want to prevent this behavior and\ndocument all available members.  Note that attributes from imported modules\nwill not be documented, because attribute documentation is discovered by\nparsing the source file of the current module.\n\nNew in version 1.2.\n\n\nAdd a list of modules in the autodoc_mock_imports to prevent\nimport errors to halt the building process when some external dependencies\nare not importable at build time.\n\nNew in version 1.3.\n\n\nAs a hint to autodoc extension, you can put a :: separator in between\nmodule name and object name to let autodoc know the correct module name if\nit is ambiguous.\n.. autoclass:: module.name::Noodle\n\n\n\nautoclass also recognizes the class-doc-from option that\ncan be used to override the global value of autoclass_content.\n\nNew in version 4.1.\n\n\n\n"
    },
    {
      "id": "directive-option-automodule-members",
      "title": ":members: (no value or comma separated list)",
      "content": "If set, autodoc will generate document for the members of the target\nmodule, class or exception.\nFor example:\n.. automodule:: noodle\n   :members:\n\n\nwill document all module members (recursively), and\n.. autoclass:: Noodle\n   :members:\n\n\nwill document all class member methods and properties.\nBy default, autodoc will not generate document for the members that are\nprivate, not having docstrings, inherited from super class, or special\nmembers.\nFor modules, __all__ will be respected when looking for members unless\nyou give the ignore-module-all flag option.  Without\nignore-module-all, the order of the members will also be the order in\n__all__.\nYou can also give an explicit list of members; only these will then be\ndocumented:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n\n"
    },
    {
      "id": "directive-option-automodule-undoc-members",
      "title": ":undoc-members: (no value)",
      "content": "If set, autodoc will also generate document for the members not having\ndocstrings:\n.. automodule:: noodle\n   :members:\n   :undoc-members:\n\n\n"
    },
    {
      "id": "directive-option-automodule-private-members",
      "title": ":private-members: (no value or comma separated list)",
      "content": "If set, autodoc will also generate document for the private members\n(that is, those named like _private or __private):\n.. automodule:: noodle\n   :members:\n   :private-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. automodule:: noodle\n   :members:\n   :private-members: _spicy, _garlickly\n\n\n\nNew in version 1.1.\n\n\nChanged in version 3.2: The option can now take arguments.\n\n"
    },
    {
      "id": "directive-option-automodule-special-members",
      "title": ":special-members: (no value or comma separated list)",
      "content": "If set, autodoc will also generate document for the special members\n(that is, those named like __special__):\n.. autoclass:: my.Class\n   :members:\n   :special-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. autoclass:: my.Class\n   :members:\n   :special-members: __init__, __name__\n\n\n\nNew in version 1.1.\n\n\nChanged in version 1.2: The option can now take arguments\n\n"
    },
    {
      "id": "directive-option-automodule-members",
      "title": ":members: (no value or comma separated list)",
      "content": "If set, autodoc will generate document for the members of the target\nmodule, class or exception.\nFor example:\n.. automodule:: noodle\n   :members:\n\n\nwill document all module members (recursively), and\n.. autoclass:: Noodle\n   :members:\n\n\nwill document all class member methods and properties.\nBy default, autodoc will not generate document for the members that are\nprivate, not having docstrings, inherited from super class, or special\nmembers.\nFor modules, __all__ will be respected when looking for members unless\nyou give the ignore-module-all flag option.  Without\nignore-module-all, the order of the members will also be the order in\n__all__.\nYou can also give an explicit list of members; only these will then be\ndocumented:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n\n"
    },
    {
      "id": "directive-option-automodule-undoc-members",
      "title": ":undoc-members: (no value)",
      "content": "If set, autodoc will also generate document for the members not having\ndocstrings:\n.. automodule:: noodle\n   :members:\n   :undoc-members:\n\n\n"
    },
    {
      "id": "directive-option-automodule-private-members",
      "title": ":private-members: (no value or comma separated list)",
      "content": "If set, autodoc will also generate document for the private members\n(that is, those named like _private or __private):\n.. automodule:: noodle\n   :members:\n   :private-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. automodule:: noodle\n   :members:\n   :private-members: _spicy, _garlickly\n\n\n\nNew in version 1.1.\n\n\nChanged in version 3.2: The option can now take arguments.\n\n"
    },
    {
      "id": "directive-option-automodule-special-members",
      "title": ":special-members: (no value or comma separated list)",
      "content": "If set, autodoc will also generate document for the special members\n(that is, those named like __special__):\n.. autoclass:: my.Class\n   :members:\n   :special-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. autoclass:: my.Class\n   :members:\n   :special-members: __init__, __name__\n\n\n\nNew in version 1.1.\n\n\nChanged in version 1.2: The option can now take arguments\n\n"
    },
    {
      "id": "directive-autofunction",
      "title": ".. autofunction::",
      "content": "These work exactly like autoclass etc.,\nbut do not offer the options used for automatic member documentation.\nautodata and autoattribute support the annotation\noption.  The option controls how the value of variable is shown.  If specified\nwithout arguments, only the name of the variable will be printed, and its value\nis not shown:\n.. autodata:: CD_DRIVE\n   :annotation:\n\n\nIf the option specified with arguments, it is printed after the name as a value\nof the variable:\n.. autodata:: CD_DRIVE\n   :annotation: = your CD device name\n\n\nBy default, without annotation option, Sphinx tries to obtain the value of\nthe variable and print it after the name.\nThe no-value option can be used instead of a blank annotation to show the\ntype hint but not the value:\n.. autodata:: CD_DRIVE\n   :no-value:\n\n\nIf both the annotation and no-value options are used, no-value has no\neffect.\nFor module data members and class attributes, documentation can either be put\ninto a comment with special formatting (using a #: to start the comment\ninstead of just #), or in a docstring after the definition.  Comments\nneed to be either on a line of their own before the definition, or\nimmediately after the assignment on the same line.  The latter form is\nrestricted to one line only.\nThis means that in the following class definition, all attributes can be\nautodocumented:\nclass Foo:\n    \"\"\"Docstring for class Foo.\"\"\"\n\n    #: Doc comment for class attribute Foo.bar.\n    #: It can have multiple lines.\n    bar = 1\n\n    flox = 1.5   #: Doc comment for Foo.flox. One line only.\n\n    baz = 2\n    \"\"\"Docstring for class attribute Foo.baz.\"\"\"\n\n    def __init__(self):\n        #: Doc comment for instance attribute qux.\n        self.qux = 3\n\n        self.spam = 4\n        \"\"\"Docstring for instance attribute spam.\"\"\"\n\n\n\nChanged in version 0.6: autodata and autoattribute can now extract\ndocstrings.\n\n\nChanged in version 1.1: Comment docs are now allowed on the same line after an assignment.\n\n\nChanged in version 1.2: autodata and autoattribute have an annotation\noption.\n\n\nChanged in version 2.0: autodecorator added.\n\n\nChanged in version 2.1: autoproperty added.\n\n\nChanged in version 3.4: autodata and autoattribute now have a no-value\noption.\n\n\nNote\nIf you document decorated functions or methods, keep in mind that autodoc\nretrieves its docstrings by importing the module and inspecting the\n__doc__ attribute of the given function or method.  That means that if\na decorator replaces the decorated function with another, it must copy the\noriginal __doc__ to the new function.\n\n"
    },
    {
      "id": "directive-autodecorator",
      "title": ".. autodecorator::",
      "content": "These work exactly like autoclass etc.,\nbut do not offer the options used for automatic member documentation.\nautodata and autoattribute support the annotation\noption.  The option controls how the value of variable is shown.  If specified\nwithout arguments, only the name of the variable will be printed, and its value\nis not shown:\n.. autodata:: CD_DRIVE\n   :annotation:\n\n\nIf the option specified with arguments, it is printed after the name as a value\nof the variable:\n.. autodata:: CD_DRIVE\n   :annotation: = your CD device name\n\n\nBy default, without annotation option, Sphinx tries to obtain the value of\nthe variable and print it after the name.\nThe no-value option can be used instead of a blank annotation to show the\ntype hint but not the value:\n.. autodata:: CD_DRIVE\n   :no-value:\n\n\nIf both the annotation and no-value options are used, no-value has no\neffect.\nFor module data members and class attributes, documentation can either be put\ninto a comment with special formatting (using a #: to start the comment\ninstead of just #), or in a docstring after the definition.  Comments\nneed to be either on a line of their own before the definition, or\nimmediately after the assignment on the same line.  The latter form is\nrestricted to one line only.\nThis means that in the following class definition, all attributes can be\nautodocumented:\nclass Foo:\n    \"\"\"Docstring for class Foo.\"\"\"\n\n    #: Doc comment for class attribute Foo.bar.\n    #: It can have multiple lines.\n    bar = 1\n\n    flox = 1.5   #: Doc comment for Foo.flox. One line only.\n\n    baz = 2\n    \"\"\"Docstring for class attribute Foo.baz.\"\"\"\n\n    def __init__(self):\n        #: Doc comment for instance attribute qux.\n        self.qux = 3\n\n        self.spam = 4\n        \"\"\"Docstring for instance attribute spam.\"\"\"\n\n\n\nChanged in version 0.6: autodata and autoattribute can now extract\ndocstrings.\n\n\nChanged in version 1.1: Comment docs are now allowed on the same line after an assignment.\n\n\nChanged in version 1.2: autodata and autoattribute have an annotation\noption.\n\n\nChanged in version 2.0: autodecorator added.\n\n\nChanged in version 2.1: autoproperty added.\n\n\nChanged in version 3.4: autodata and autoattribute now have a no-value\noption.\n\n\nNote\nIf you document decorated functions or methods, keep in mind that autodoc\nretrieves its docstrings by importing the module and inspecting the\n__doc__ attribute of the given function or method.  That means that if\na decorator replaces the decorated function with another, it must copy the\noriginal __doc__ to the new function.\n\n"
    },
    {
      "id": "directive-autodata",
      "title": ".. autodata::",
      "content": "These work exactly like autoclass etc.,\nbut do not offer the options used for automatic member documentation.\nautodata and autoattribute support the annotation\noption.  The option controls how the value of variable is shown.  If specified\nwithout arguments, only the name of the variable will be printed, and its value\nis not shown:\n.. autodata:: CD_DRIVE\n   :annotation:\n\n\nIf the option specified with arguments, it is printed after the name as a value\nof the variable:\n.. autodata:: CD_DRIVE\n   :annotation: = your CD device name\n\n\nBy default, without annotation option, Sphinx tries to obtain the value of\nthe variable and print it after the name.\nThe no-value option can be used instead of a blank annotation to show the\ntype hint but not the value:\n.. autodata:: CD_DRIVE\n   :no-value:\n\n\nIf both the annotation and no-value options are used, no-value has no\neffect.\nFor module data members and class attributes, documentation can either be put\ninto a comment with special formatting (using a #: to start the comment\ninstead of just #), or in a docstring after the definition.  Comments\nneed to be either on a line of their own before the definition, or\nimmediately after the assignment on the same line.  The latter form is\nrestricted to one line only.\nThis means that in the following class definition, all attributes can be\nautodocumented:\nclass Foo:\n    \"\"\"Docstring for class Foo.\"\"\"\n\n    #: Doc comment for class attribute Foo.bar.\n    #: It can have multiple lines.\n    bar = 1\n\n    flox = 1.5   #: Doc comment for Foo.flox. One line only.\n\n    baz = 2\n    \"\"\"Docstring for class attribute Foo.baz.\"\"\"\n\n    def __init__(self):\n        #: Doc comment for instance attribute qux.\n        self.qux = 3\n\n        self.spam = 4\n        \"\"\"Docstring for instance attribute spam.\"\"\"\n\n\n\nChanged in version 0.6: autodata and autoattribute can now extract\ndocstrings.\n\n\nChanged in version 1.1: Comment docs are now allowed on the same line after an assignment.\n\n\nChanged in version 1.2: autodata and autoattribute have an annotation\noption.\n\n\nChanged in version 2.0: autodecorator added.\n\n\nChanged in version 2.1: autoproperty added.\n\n\nChanged in version 3.4: autodata and autoattribute now have a no-value\noption.\n\n\nNote\nIf you document decorated functions or methods, keep in mind that autodoc\nretrieves its docstrings by importing the module and inspecting the\n__doc__ attribute of the given function or method.  That means that if\na decorator replaces the decorated function with another, it must copy the\noriginal __doc__ to the new function.\n\n"
    },
    {
      "id": "directive-automethod",
      "title": ".. automethod::",
      "content": "These work exactly like autoclass etc.,\nbut do not offer the options used for automatic member documentation.\nautodata and autoattribute support the annotation\noption.  The option controls how the value of variable is shown.  If specified\nwithout arguments, only the name of the variable will be printed, and its value\nis not shown:\n.. autodata:: CD_DRIVE\n   :annotation:\n\n\nIf the option specified with arguments, it is printed after the name as a value\nof the variable:\n.. autodata:: CD_DRIVE\n   :annotation: = your CD device name\n\n\nBy default, without annotation option, Sphinx tries to obtain the value of\nthe variable and print it after the name.\nThe no-value option can be used instead of a blank annotation to show the\ntype hint but not the value:\n.. autodata:: CD_DRIVE\n   :no-value:\n\n\nIf both the annotation and no-value options are used, no-value has no\neffect.\nFor module data members and class attributes, documentation can either be put\ninto a comment with special formatting (using a #: to start the comment\ninstead of just #), or in a docstring after the definition.  Comments\nneed to be either on a line of their own before the definition, or\nimmediately after the assignment on the same line.  The latter form is\nrestricted to one line only.\nThis means that in the following class definition, all attributes can be\nautodocumented:\nclass Foo:\n    \"\"\"Docstring for class Foo.\"\"\"\n\n    #: Doc comment for class attribute Foo.bar.\n    #: It can have multiple lines.\n    bar = 1\n\n    flox = 1.5   #: Doc comment for Foo.flox. One line only.\n\n    baz = 2\n    \"\"\"Docstring for class attribute Foo.baz.\"\"\"\n\n    def __init__(self):\n        #: Doc comment for instance attribute qux.\n        self.qux = 3\n\n        self.spam = 4\n        \"\"\"Docstring for instance attribute spam.\"\"\"\n\n\n\nChanged in version 0.6: autodata and autoattribute can now extract\ndocstrings.\n\n\nChanged in version 1.1: Comment docs are now allowed on the same line after an assignment.\n\n\nChanged in version 1.2: autodata and autoattribute have an annotation\noption.\n\n\nChanged in version 2.0: autodecorator added.\n\n\nChanged in version 2.1: autoproperty added.\n\n\nChanged in version 3.4: autodata and autoattribute now have a no-value\noption.\n\n\nNote\nIf you document decorated functions or methods, keep in mind that autodoc\nretrieves its docstrings by importing the module and inspecting the\n__doc__ attribute of the given function or method.  That means that if\na decorator replaces the decorated function with another, it must copy the\noriginal __doc__ to the new function.\n\n"
    },
    {
      "id": "directive-autoattribute",
      "title": ".. autoattribute::",
      "content": "These work exactly like autoclass etc.,\nbut do not offer the options used for automatic member documentation.\nautodata and autoattribute support the annotation\noption.  The option controls how the value of variable is shown.  If specified\nwithout arguments, only the name of the variable will be printed, and its value\nis not shown:\n.. autodata:: CD_DRIVE\n   :annotation:\n\n\nIf the option specified with arguments, it is printed after the name as a value\nof the variable:\n.. autodata:: CD_DRIVE\n   :annotation: = your CD device name\n\n\nBy default, without annotation option, Sphinx tries to obtain the value of\nthe variable and print it after the name.\nThe no-value option can be used instead of a blank annotation to show the\ntype hint but not the value:\n.. autodata:: CD_DRIVE\n   :no-value:\n\n\nIf both the annotation and no-value options are used, no-value has no\neffect.\nFor module data members and class attributes, documentation can either be put\ninto a comment with special formatting (using a #: to start the comment\ninstead of just #), or in a docstring after the definition.  Comments\nneed to be either on a line of their own before the definition, or\nimmediately after the assignment on the same line.  The latter form is\nrestricted to one line only.\nThis means that in the following class definition, all attributes can be\nautodocumented:\nclass Foo:\n    \"\"\"Docstring for class Foo.\"\"\"\n\n    #: Doc comment for class attribute Foo.bar.\n    #: It can have multiple lines.\n    bar = 1\n\n    flox = 1.5   #: Doc comment for Foo.flox. One line only.\n\n    baz = 2\n    \"\"\"Docstring for class attribute Foo.baz.\"\"\"\n\n    def __init__(self):\n        #: Doc comment for instance attribute qux.\n        self.qux = 3\n\n        self.spam = 4\n        \"\"\"Docstring for instance attribute spam.\"\"\"\n\n\n\nChanged in version 0.6: autodata and autoattribute can now extract\ndocstrings.\n\n\nChanged in version 1.1: Comment docs are now allowed on the same line after an assignment.\n\n\nChanged in version 1.2: autodata and autoattribute have an annotation\noption.\n\n\nChanged in version 2.0: autodecorator added.\n\n\nChanged in version 2.1: autoproperty added.\n\n\nChanged in version 3.4: autodata and autoattribute now have a no-value\noption.\n\n\nNote\nIf you document decorated functions or methods, keep in mind that autodoc\nretrieves its docstrings by importing the module and inspecting the\n__doc__ attribute of the given function or method.  That means that if\na decorator replaces the decorated function with another, it must copy the\noriginal __doc__ to the new function.\n\n"
    },
    {
      "id": "directive-autoproperty",
      "title": ".. autoproperty::",
      "content": "These work exactly like autoclass etc.,\nbut do not offer the options used for automatic member documentation.\nautodata and autoattribute support the annotation\noption.  The option controls how the value of variable is shown.  If specified\nwithout arguments, only the name of the variable will be printed, and its value\nis not shown:\n.. autodata:: CD_DRIVE\n   :annotation:\n\n\nIf the option specified with arguments, it is printed after the name as a value\nof the variable:\n.. autodata:: CD_DRIVE\n   :annotation: = your CD device name\n\n\nBy default, without annotation option, Sphinx tries to obtain the value of\nthe variable and print it after the name.\nThe no-value option can be used instead of a blank annotation to show the\ntype hint but not the value:\n.. autodata:: CD_DRIVE\n   :no-value:\n\n\nIf both the annotation and no-value options are used, no-value has no\neffect.\nFor module data members and class attributes, documentation can either be put\ninto a comment with special formatting (using a #: to start the comment\ninstead of just #), or in a docstring after the definition.  Comments\nneed to be either on a line of their own before the definition, or\nimmediately after the assignment on the same line.  The latter form is\nrestricted to one line only.\nThis means that in the following class definition, all attributes can be\nautodocumented:\nclass Foo:\n    \"\"\"Docstring for class Foo.\"\"\"\n\n    #: Doc comment for class attribute Foo.bar.\n    #: It can have multiple lines.\n    bar = 1\n\n    flox = 1.5   #: Doc comment for Foo.flox. One line only.\n\n    baz = 2\n    \"\"\"Docstring for class attribute Foo.baz.\"\"\"\n\n    def __init__(self):\n        #: Doc comment for instance attribute qux.\n        self.qux = 3\n\n        self.spam = 4\n        \"\"\"Docstring for instance attribute spam.\"\"\"\n\n\n\nChanged in version 0.6: autodata and autoattribute can now extract\ndocstrings.\n\n\nChanged in version 1.1: Comment docs are now allowed on the same line after an assignment.\n\n\nChanged in version 1.2: autodata and autoattribute have an annotation\noption.\n\n\nChanged in version 2.0: autodecorator added.\n\n\nChanged in version 2.1: autoproperty added.\n\n\nChanged in version 3.4: autodata and autoattribute now have a no-value\noption.\n\n\nNote\nIf you document decorated functions or methods, keep in mind that autodoc\nretrieves its docstrings by importing the module and inspecting the\n__doc__ attribute of the given function or method.  That means that if\na decorator replaces the decorated function with another, it must copy the\noriginal __doc__ to the new function.\n\n"
    },
    {
      "id": "confval-autoclass_content",
      "title": "autoclass_content",
      "content": "This value selects what content will be inserted into the main body of an\nautoclass directive.  The possible values are:\n\n\"class\"Only the class\u2019 docstring is inserted.  This is the default.  You can\nstill document __init__ as a separate method using\nautomethod or the members option to autoclass.\n\n\"both\"Both the class\u2019 and the __init__ method\u2019s docstring are concatenated\nand inserted.\n\n\"init\"Only the __init__ method\u2019s docstring is inserted.\n\n\n\nNew in version 0.3.\n\nIf the class has no __init__ method or if the __init__ method\u2019s\ndocstring is empty, but the class has a __new__ method\u2019s docstring,\nit is used instead.\n\nNew in version 1.4.\n\n"
    },
    {
      "id": "confval-autodoc_class_signature",
      "title": "autodoc_class_signature",
      "content": "This value selects how the signature will be displayed for the class defined\nby autoclass directive.  The possible values are:\n\n\"mixed\"Display the signature with the class name.\n\n\"separated\"Display the signature as a method.\n\n\nThe default is \"mixed\".\n\nNew in version 4.1.\n\n"
    },
    {
      "id": "confval-autodoc_member_order",
      "title": "autodoc_member_order",
      "content": "This value selects if automatically documented members are sorted\nalphabetical (value 'alphabetical'), by member type (value\n'groupwise') or by source order (value 'bysource').  The default is\nalphabetical.\nNote that for source order, the module must be a Python module with the\nsource code available.\n\nNew in version 0.6.\n\n\nChanged in version 1.0: Support for 'bysource'.\n\n"
    },
    {
      "id": "confval-autodoc_default_flags",
      "title": "autodoc_default_flags",
      "content": "This value is a list of autodoc directive flags that should be automatically\napplied to all autodoc directives.  The supported flags are 'members',\n'undoc-members', 'private-members', 'special-members',\n'inherited-members', 'show-inheritance', 'ignore-module-all'\nand 'exclude-members'.\n\nNew in version 1.0.\n\n\nDeprecated since version 1.8: Integrated into autodoc_default_options.\n\n"
    },
    {
      "id": "confval-autodoc_default_options",
      "title": "autodoc_default_options",
      "content": "The default options for autodoc directives.  They are applied to all autodoc\ndirectives automatically.  It must be a dictionary which maps option names\nto the values.  For example:\nautodoc_default_options = {\n    'members': 'var1, var2',\n    'member-order': 'bysource',\n    'special-members': '__init__',\n    'undoc-members': True,\n    'exclude-members': '__weakref__'\n}\n\n\nSetting None or True to the value is equivalent to giving only the\noption name to the directives.\nThe supported options are 'members', 'member-order',\n'undoc-members', 'private-members', 'special-members',\n'inherited-members', 'show-inheritance', 'ignore-module-all',\n'imported-members', 'exclude-members', 'class-doc-from' and\n'no-value'.\n\nNew in version 1.8.\n\n\nChanged in version 2.0: Accepts True as a value.\n\n\nChanged in version 2.1: Added 'imported-members'.\n\n\nChanged in version 4.1: Added 'class-doc-from'.\n\n\nChanged in version 4.5: Added 'no-value'.\n\n"
    },
    {
      "id": "confval-autodoc_docstring_signature",
      "title": "autodoc_docstring_signature",
      "content": "Functions imported from C modules cannot be introspected, and therefore the\nsignature for such functions cannot be automatically determined.  However, it\nis an often-used convention to put the signature into the first line of the\nfunction\u2019s docstring.\nIf this boolean value is set to True (which is the default), autodoc will\nlook at the first line of the docstring for functions and methods, and if it\nlooks like a signature, use the line as the signature and remove it from the\ndocstring content.\nautodoc will continue to look for multiple signature lines,\nstopping at the first line that does not look like a signature.\nThis is useful for declaring overloaded function signatures.\n\nNew in version 1.1.\n\n\nChanged in version 3.1: Support overloaded signatures\n\n\nChanged in version 4.0: Overloaded signatures do not need to be separated by a backslash\n\n"
    },
    {
      "id": "confval-autodoc_mock_imports",
      "title": "autodoc_mock_imports",
      "content": "This value contains a list of modules to be mocked up. This is useful when\nsome external dependencies are not met at build time and break the building\nprocess. You may only specify the root package of the dependencies\nthemselves and omit the sub-modules:\nautodoc_mock_imports = [\"django\"]\n\n\nWill mock all imports under the django package.\n\nNew in version 1.3.\n\n\nChanged in version 1.6: This config value only requires to declare the top-level modules that\nshould be mocked.\n\n"
    },
    {
      "id": "confval-autodoc_typehints",
      "title": "autodoc_typehints",
      "content": "This value controls how to represent typehints.  The setting takes the\nfollowing values:\n\n'signature' \u2013 Show typehints in the signature (default)\n'description' \u2013 Show typehints as content of the function or method\nThe typehints of overloaded functions or methods will still be represented\nin the signature.\n'none' \u2013 Do not show typehints\n'both' \u2013 Show typehints in the signature and as content of\nthe function or method\n\nOverloaded functions or methods will not have typehints included in the\ndescription because it is impossible to accurately represent all possible\noverloads as a list of parameters.\n\nNew in version 2.1.\n\n\nNew in version 3.0: New option 'description' is added.\n\n\nNew in version 4.1: New option 'both' is added.\n\n"
    },
    {
      "id": "confval-autodoc_typehints_description_target",
      "title": "autodoc_typehints_description_target",
      "content": "This value controls whether the types of undocumented parameters and return\nvalues are documented when autodoc_typehints is set to description.\nThe default value is \"all\", meaning that types are documented for all\nparameters and return values, whether they are documented or not.\nWhen set to \"documented\", types will only be documented for a parameter\nor a return value that is already documented by the docstring.\nWith \"documented_params\", parameter types will only be annotated if the\nparameter is documented in the docstring. The return type is always\nannotated (except if it is None).\n\nNew in version 4.0.\n\n\nNew in version 5.0: New option 'documented_params' is added.\n\n"
    },
    {
      "id": "confval-autodoc_type_aliases",
      "title": "autodoc_type_aliases",
      "content": "A dictionary for users defined type aliases that maps a type name to the\nfull-qualified object name.  It is used to keep type aliases not evaluated in\nthe document.  Defaults to empty ({}).\nThe type aliases are only available if your program enables Postponed\nEvaluation of Annotations (PEP 563) feature via from __future__ import\nannotations.\nFor example, there is code using a type alias:\nfrom __future__ import annotations\n\nAliasType = Union[List[Dict[Tuple[int, str], Set[int]]], Tuple[str, List[str]]]\n\ndef f() -> AliasType:\n    ...\n\n\nIf autodoc_type_aliases is not set, autodoc will generate internal mark-up\nfrom this code as following:\n.. py:function:: f() -> Union[List[Dict[Tuple[int, str], Set[int]]], Tuple[str, List[str]]]\n\n   ...\n\n\nIf you set autodoc_type_aliases as\n{'AliasType': 'your.module.AliasType'}, it generates the following document\ninternally:\n.. py:function:: f() -> your.module.AliasType:\n\n   ...\n\n\n\nNew in version 3.3.\n\n"
    },
    {
      "id": "confval-autodoc_typehints_format",
      "title": "autodoc_typehints_format",
      "content": "This value controls the format of typehints.  The setting takes the\nfollowing values:\n\n'fully-qualified' \u2013 Show the module name and its name of typehints\n'short' \u2013 Suppress the leading module names of the typehints\n(ex. io.StringIO -> StringIO)  (default)\n\n\nNew in version 4.4.\n\n\nChanged in version 5.0: The default setting was changed to 'short'\n\n"
    },
    {
      "id": "confval-autodoc_preserve_defaults",
      "title": "autodoc_preserve_defaults",
      "content": "If True, the default argument values of functions will be not evaluated on\ngenerating document.  It preserves them as is in the source code.\n\nNew in version 4.0: Added as an experimental feature.  This will be integrated into autodoc core\nin the future.\n\n"
    },
    {
      "id": "confval-autodoc_warningiserror",
      "title": "autodoc_warningiserror",
      "content": "This value controls the behavior of sphinx-build -W during\nimporting modules.\nIf False is given, autodoc forcedly suppresses the error if the imported\nmodule emits warnings.  By default, True.\n"
    },
    {
      "id": "confval-autodoc_inherit_docstrings",
      "title": "autodoc_inherit_docstrings",
      "content": "This value controls the docstrings inheritance.\nIf set to True the docstring for classes or methods, if not explicitly set,\nis inherited from parents.\nThe default is True.\n\nNew in version 1.7.\n\n"
    },
    {
      "id": "event-autodoc-process-docstring",
      "title": "autodoc-process-docstring(app, what, name, obj, options, lines)",
      "content": "\nNew in version 0.4.\n\nEmitted when autodoc has read and processed a docstring.  lines is a list\nof strings \u2013 the lines of the processed docstring \u2013 that the event handler\ncan modify in place to change what Sphinx puts into the output.\n\nParameters:\n\napp \u2013 the Sphinx application object\nwhat \u2013 the type of the object which the docstring belongs to (one of\n\"module\", \"class\", \"exception\", \"function\", \"method\",\n\"attribute\")\nname \u2013 the fully qualified name of the object\nobj \u2013 the object itself\noptions \u2013 the options given to the directive: an object with attributes\ninherited_members, undoc_members, show_inheritance and\nnoindex that are true if the flag option of same name was given to the\nauto directive\nlines \u2013 the lines of the docstring, see above\n\n\n\n"
    },
    {
      "id": "event-autodoc-before-process-signature",
      "title": "autodoc-before-process-signature(app, obj, bound_method)",
      "content": "\nNew in version 2.4.\n\nEmitted before autodoc formats a signature for an object. The event handler\ncan modify an object to change its signature.\n\nParameters:\n\napp \u2013 the Sphinx application object\nobj \u2013 the object itself\nbound_method \u2013 a boolean indicates an object is bound method or not\n\n\n\n"
    },
    {
      "id": "event-autodoc-process-signature",
      "title": "autodoc-process-signature(app, what, name, obj, options, signature, return_annotation)",
      "content": "\nNew in version 0.5.\n\nEmitted when autodoc has formatted a signature for an object. The event\nhandler can return a new tuple (signature, return_annotation) to change\nwhat Sphinx puts into the output.\n\nParameters:\n\napp \u2013 the Sphinx application object\nwhat \u2013 the type of the object which the docstring belongs to (one of\n\"module\", \"class\", \"exception\", \"function\", \"method\",\n\"attribute\")\nname \u2013 the fully qualified name of the object\nobj \u2013 the object itself\noptions \u2013 the options given to the directive: an object with attributes\ninherited_members, undoc_members, show_inheritance and\nnoindex that are true if the flag option of same name was given to the\nauto directive\nsignature \u2013 function signature, as a string of the form\n\"(parameter_1, parameter_2)\", or None if introspection didn\u2019t\nsucceed and signature wasn\u2019t specified in the directive.\nreturn_annotation \u2013 function return annotation as a string of the form\n\" -> annotation\", or None if there is no return annotation\n\n\n\n"
    },
    {
      "id": "sphinx.ext.autodoc.cut_lines",
      "title": "sphinx.ext.autodoc.cut_lines(pre: int, post: int = 0, what: str | None = None) \u2192 Callable[source]",
      "content": "Return a listener that removes the first pre and last post\nlines of every docstring.  If what is a sequence of strings,\nonly docstrings of a type in what will be processed.\nUse like this (e.g. in the setup() function of conf.py):\nfrom sphinx.ext.autodoc import cut_lines\napp.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n\n\nThis can (and should) be used in place of automodule_skip_lines.\n"
    },
    {
      "id": "sphinx.ext.autodoc.between",
      "title": "sphinx.ext.autodoc.between(marker: str, what: Sequence[str] | None = None, keepempty: bool = False, exclude: bool = False) \u2192 Callable[source]",
      "content": "Return a listener that either keeps, or if exclude is True excludes,\nlines between lines that match the marker regular expression.  If no line\nmatches, the resulting docstring would be empty, so no change will be made\nunless keepempty is true.\nIf what is a sequence of strings, only docstrings of a type in what will\nbe processed.\n"
    },
    {
      "id": "event-autodoc-process-bases",
      "title": "autodoc-process-bases(app, name, obj, options, bases)",
      "content": "Emitted when autodoc has read and processed a class to determine the\nbase-classes.  bases is a list of classes that the event handler can\nmodify in place to change what Sphinx puts into the output.  It\u2019s\nemitted only if show-inheritance option given.\n\nParameters:\n\napp \u2013 the Sphinx application object\nname \u2013 the fully qualified name of the object\nobj \u2013 the object itself\noptions \u2013 the options given to the class directive\nbases \u2013 the list of base classes signature. see above.\n\n\n\n\nNew in version 4.1.\n\n\nChanged in version 4.3: bases can contain a string as a base class name.  It will be processed\nas reST mark-up\u2019ed text.\n\n"
    },
    {
      "id": "event-autodoc-skip-member",
      "title": "autodoc-skip-member(app, what, name, obj, skip, options)",
      "content": "\nNew in version 0.5.\n\nEmitted when autodoc has to decide whether a member should be included in the\ndocumentation.  The member is excluded if a handler returns True.  It is\nincluded if the handler returns False.\nIf more than one enabled extension handles the autodoc-skip-member\nevent, autodoc will use the first non-None value returned by a handler.\nHandlers should return None to fall back to the skipping behavior of\nautodoc and other enabled extensions.\n\nParameters:\n\napp \u2013 the Sphinx application object\nwhat \u2013 the type of the object which the docstring belongs to (one of\n\"module\", \"class\", \"exception\", \"function\", \"method\",\n\"attribute\")\nname \u2013 the fully qualified name of the object\nobj \u2013 the object itself\nskip \u2013 a boolean indicating if autodoc will skip this member if the\nuser handler does not override the decision\noptions \u2013 the options given to the directive: an object with attributes\ninherited_members, undoc_members, show_inheritance and\nnoindex that are true if the flag option of same name was given to the\nauto directive\n\n\n\n"
    },
    {
      "id": "module-sphinx.ext.autodoc",
      "title": "sphinx.ext.autodoc \u2013 Include documentation from docstrings",
      "content": "This extension can import the modules you are documenting, and pull in documentation from docstrings in a semi-automatic way. Note For Sphinx (actually, the Python interpreter that executes Sphinx) to find your module, it must be importable. That means that the module or the package must be in one of the directories on sys.path \u2013 adapt your sys.path in the configuration file accordingly. Warning autodoc imports the modules to be documented. If any modules have side effects on import, these will be executed by autodoc when sphinx-build is run. If you document scripts (as opposed to library modules), make sure their main routine is protected by a if __name__ == '__main__' condition. For this to work, the docstrings must of course be written in correct reStructuredText. You can then use all of the usual Sphinx markup in the docstrings, and it will end up correctly in the documentation. Together with hand-written documentation, this technique eases the pain of having to maintain two locations for documentation, while at the same time avoiding auto-generated-looking pure API documentation. If you prefer NumPy or Google style docstrings over reStructuredText, you can also enable the napoleon extension. napoleon is a preprocessor that converts your docstrings to correct reStructuredText before autodoc processes them."
    },
    {
      "id": "directives",
      "title": "Directives",
      "content": "autodoc provides several directives that are versions of the usual py:module, py:class and so forth. On parsing time, they import the corresponding module and extract the docstring of the given objects, inserting them into the page source under a suitable py:module, py:class etc. directive. Note Just as py:class respects the current py:module, autoclass will also do so. Likewise, automethod will respect the current py:class."
    },
    {
      "id": "configuration",
      "title": "Configuration",
      "content": "There are also config values that you can set:"
    },
    {
      "id": "docstring-preprocessing",
      "title": "Docstring preprocessing",
      "content": "autodoc provides the following additional events: The sphinx.ext.autodoc module provides factory functions for commonly needed docstring processing in event autodoc-process-docstring:"
    },
    {
      "id": "skipping-members",
      "title": "Skipping members",
      "content": "autodoc allows the user to define a custom method for determining whether a member should be included in the documentation by using the following event:"
    }
  ],
  "domain_data": {}
}
