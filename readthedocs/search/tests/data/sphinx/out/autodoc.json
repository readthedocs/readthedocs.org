{
  "path": "autodoc.html",
  "title": "sphinx.ext.autodoc â€“ Include documentation from docstrings",
  "sections": [
    {
      "id": "directive-automodule",
      "title": ".. automodule::",
      "content": "Document a module, class or exception. All three directives will by default only insert the docstring of the object itself: .. autoclass:: Noodle will produce source like this: .. class:: Noodle Noodle's docstring. The \u201cauto\u201d directives can also contain content of their own, it will be inserted into the resulting non-auto directive source after the docstring (but before any automatic member documentation). Therefore, you can also mix automatic and non-automatic member documentation, like so: .. autoclass:: Noodle :members: eat, slurp .. method:: boil(time=10) Boil the noodle *time* minutes. Options Options and advanced usage If you want to make the members option (or other options described below) the default, see autodoc_default_options. Tip You can use a negated form, 'no-flag', as an option of autodoc directive, to disable it temporarily. For example: .. automodule:: foo :no-undoc-members: Tip You can use autodoc directive options to temporarily override or extend default options which takes list as an input. For example: .. autoclass:: Noodle :members: eat :private-members: +_spicy, _garlickly Changed in version 3.5: The default options can be overridden or extended temporarily. autodoc considers a member private if its docstring contains :meta private: in its Info field lists. For example: def my_function(my_arg, my_other_arg): \"\"\"blah blah blah :meta private: \"\"\" New in version 3.0. autodoc considers a member public if its docstring contains :meta public: in its Info field lists, even if it starts with an underscore. For example: def _my_function(my_arg, my_other_arg): \"\"\"blah blah blah :meta public: \"\"\" New in version 3.1. autodoc considers a variable member does not have any default value if its docstring contains :meta hide-value: in its Info field lists. Example: var1 = None #: :meta hide-value: New in version 3.5. For classes and exceptions, members inherited from base classes will be left out when documenting all members, unless you give the inherited-members option, in addition to members: .. autoclass:: Noodle :members: :inherited-members: This can be combined with undoc-members to document all available members of the class or module. It can take an ancestor class not to document inherited members from it. By default, members of object class are not documented. To show them all, give None to the option. For example; If your class Foo is derived from list class and you don\u2019t want to document list.__len__(), you should specify a option :inherited-members: list to avoid special members of list class. Another example; If your class Foo has __str__ special method and autodoc directive has both inherited-members and special-members, __str__ will be documented as in the past, but other special method that are not implemented in your class Foo. Since v5.0, it can take a comma separated list of ancestor classes. It allows to suppress inherited members of several classes on the module at once by specifying the option to automodule directive. Note: this will lead to markup errors if the inherited members come from a module whose docstrings are not reST formatted. New in version 0.3. Changed in version 3.0: It takes an ancestor class name as an argument. Changed in version 5.0: It takes a comma separated list of ancestor class names. It\u2019s possible to override the signature for explicitly documented callable objects (functions, methods, classes) with the regular syntax that will override the signature gained from introspection: .. autoclass:: Noodle(type) .. automethod:: eat(persona) This is useful if the signature from the method is hidden by a decorator. New in version 0.4. The automodule, autoclass and autoexception directives also support a flag option called show-inheritance. When given, a list of base classes will be inserted just below the class signature (when used with automodule, this will be inserted for every class that is documented in the module). New in version 0.4. All autodoc directives support the noindex flag option that has the same effect as for standard py:function etc. directives: no index entries are generated for the documented object (and all autodocumented members). New in version 0.4. automodule also recognizes the synopsis, platform and deprecated options that the standard py:module directive supports. New in version 0.5. automodule and autoclass also has an member-order option that can be used to override the global value of autodoc_member_order for one directive. New in version 0.6. The directives supporting member documentation also have a exclude-members option that can be used to exclude single member names from documentation, if all members are to be documented. New in version 0.6. In an automodule directive with the members option set, only module members whose __module__ attribute is equal to the module name as given to automodule will be documented. This is to prevent documentation of imported classes or functions. Set the imported-members option if you want to prevent this behavior and document all available members. Note that attributes from imported modules will not be documented, because attribute documentation is discovered by parsing the source file of the current module. New in version 1.2. Add a list of modules in the autodoc_mock_imports to prevent import errors to halt the building process when some external dependencies are not importable at build time. New in version 1.3. As a hint to autodoc extension, you can put a :: separator in between module name and object name to let autodoc know the correct module name if it is ambiguous. .. autoclass:: module.name::Noodle autoclass also recognizes the class-doc-from option that can be used to override the global value of autoclass_content. New in version 4.1."
    },
    {
      "id": "directive-autoclass",
      "title": ".. autoclass::",
      "content": "Document a module, class or exception. All three directives will by default only insert the docstring of the object itself: .. autoclass:: Noodle will produce source like this: .. class:: Noodle Noodle's docstring. The \u201cauto\u201d directives can also contain content of their own, it will be inserted into the resulting non-auto directive source after the docstring (but before any automatic member documentation). Therefore, you can also mix automatic and non-automatic member documentation, like so: .. autoclass:: Noodle :members: eat, slurp .. method:: boil(time=10) Boil the noodle *time* minutes. Options Options and advanced usage If you want to make the members option (or other options described below) the default, see autodoc_default_options. Tip You can use a negated form, 'no-flag', as an option of autodoc directive, to disable it temporarily. For example: .. automodule:: foo :no-undoc-members: Tip You can use autodoc directive options to temporarily override or extend default options which takes list as an input. For example: .. autoclass:: Noodle :members: eat :private-members: +_spicy, _garlickly Changed in version 3.5: The default options can be overridden or extended temporarily. autodoc considers a member private if its docstring contains :meta private: in its Info field lists. For example: def my_function(my_arg, my_other_arg): \"\"\"blah blah blah :meta private: \"\"\" New in version 3.0. autodoc considers a member public if its docstring contains :meta public: in its Info field lists, even if it starts with an underscore. For example: def _my_function(my_arg, my_other_arg): \"\"\"blah blah blah :meta public: \"\"\" New in version 3.1. autodoc considers a variable member does not have any default value if its docstring contains :meta hide-value: in its Info field lists. Example: var1 = None #: :meta hide-value: New in version 3.5. For classes and exceptions, members inherited from base classes will be left out when documenting all members, unless you give the inherited-members option, in addition to members: .. autoclass:: Noodle :members: :inherited-members: This can be combined with undoc-members to document all available members of the class or module. It can take an ancestor class not to document inherited members from it. By default, members of object class are not documented. To show them all, give None to the option. For example; If your class Foo is derived from list class and you don\u2019t want to document list.__len__(), you should specify a option :inherited-members: list to avoid special members of list class. Another example; If your class Foo has __str__ special method and autodoc directive has both inherited-members and special-members, __str__ will be documented as in the past, but other special method that are not implemented in your class Foo. Since v5.0, it can take a comma separated list of ancestor classes. It allows to suppress inherited members of several classes on the module at once by specifying the option to automodule directive. Note: this will lead to markup errors if the inherited members come from a module whose docstrings are not reST formatted. New in version 0.3. Changed in version 3.0: It takes an ancestor class name as an argument. Changed in version 5.0: It takes a comma separated list of ancestor class names. It\u2019s possible to override the signature for explicitly documented callable objects (functions, methods, classes) with the regular syntax that will override the signature gained from introspection: .. autoclass:: Noodle(type) .. automethod:: eat(persona) This is useful if the signature from the method is hidden by a decorator. New in version 0.4. The automodule, autoclass and autoexception directives also support a flag option called show-inheritance. When given, a list of base classes will be inserted just below the class signature (when used with automodule, this will be inserted for every class that is documented in the module). New in version 0.4. All autodoc directives support the noindex flag option that has the same effect as for standard py:function etc. directives: no index entries are generated for the documented object (and all autodocumented members). New in version 0.4. automodule also recognizes the synopsis, platform and deprecated options that the standard py:module directive supports. New in version 0.5. automodule and autoclass also has an member-order option that can be used to override the global value of autodoc_member_order for one directive. New in version 0.6. The directives supporting member documentation also have a exclude-members option that can be used to exclude single member names from documentation, if all members are to be documented. New in version 0.6. In an automodule directive with the members option set, only module members whose __module__ attribute is equal to the module name as given to automodule will be documented. This is to prevent documentation of imported classes or functions. Set the imported-members option if you want to prevent this behavior and document all available members. Note that attributes from imported modules will not be documented, because attribute documentation is discovered by parsing the source file of the current module. New in version 1.2. Add a list of modules in the autodoc_mock_imports to prevent import errors to halt the building process when some external dependencies are not importable at build time. New in version 1.3. As a hint to autodoc extension, you can put a :: separator in between module name and object name to let autodoc know the correct module name if it is ambiguous. .. autoclass:: module.name::Noodle autoclass also recognizes the class-doc-from option that can be used to override the global value of autoclass_content. New in version 4.1."
    },
    {
      "id": "directive-autoexception",
      "title": ".. autoexception::",
      "content": "Document a module, class or exception. All three directives will by default only insert the docstring of the object itself: .. autoclass:: Noodle will produce source like this: .. class:: Noodle Noodle's docstring. The \u201cauto\u201d directives can also contain content of their own, it will be inserted into the resulting non-auto directive source after the docstring (but before any automatic member documentation). Therefore, you can also mix automatic and non-automatic member documentation, like so: .. autoclass:: Noodle :members: eat, slurp .. method:: boil(time=10) Boil the noodle *time* minutes. Options Options and advanced usage If you want to make the members option (or other options described below) the default, see autodoc_default_options. Tip You can use a negated form, 'no-flag', as an option of autodoc directive, to disable it temporarily. For example: .. automodule:: foo :no-undoc-members: Tip You can use autodoc directive options to temporarily override or extend default options which takes list as an input. For example: .. autoclass:: Noodle :members: eat :private-members: +_spicy, _garlickly Changed in version 3.5: The default options can be overridden or extended temporarily. autodoc considers a member private if its docstring contains :meta private: in its Info field lists. For example: def my_function(my_arg, my_other_arg): \"\"\"blah blah blah :meta private: \"\"\" New in version 3.0. autodoc considers a member public if its docstring contains :meta public: in its Info field lists, even if it starts with an underscore. For example: def _my_function(my_arg, my_other_arg): \"\"\"blah blah blah :meta public: \"\"\" New in version 3.1. autodoc considers a variable member does not have any default value if its docstring contains :meta hide-value: in its Info field lists. Example: var1 = None #: :meta hide-value: New in version 3.5. For classes and exceptions, members inherited from base classes will be left out when documenting all members, unless you give the inherited-members option, in addition to members: .. autoclass:: Noodle :members: :inherited-members: This can be combined with undoc-members to document all available members of the class or module. It can take an ancestor class not to document inherited members from it. By default, members of object class are not documented. To show them all, give None to the option. For example; If your class Foo is derived from list class and you don\u2019t want to document list.__len__(), you should specify a option :inherited-members: list to avoid special members of list class. Another example; If your class Foo has __str__ special method and autodoc directive has both inherited-members and special-members, __str__ will be documented as in the past, but other special method that are not implemented in your class Foo. Since v5.0, it can take a comma separated list of ancestor classes. It allows to suppress inherited members of several classes on the module at once by specifying the option to automodule directive. Note: this will lead to markup errors if the inherited members come from a module whose docstrings are not reST formatted. New in version 0.3. Changed in version 3.0: It takes an ancestor class name as an argument. Changed in version 5.0: It takes a comma separated list of ancestor class names. It\u2019s possible to override the signature for explicitly documented callable objects (functions, methods, classes) with the regular syntax that will override the signature gained from introspection: .. autoclass:: Noodle(type) .. automethod:: eat(persona) This is useful if the signature from the method is hidden by a decorator. New in version 0.4. The automodule, autoclass and autoexception directives also support a flag option called show-inheritance. When given, a list of base classes will be inserted just below the class signature (when used with automodule, this will be inserted for every class that is documented in the module). New in version 0.4. All autodoc directives support the noindex flag option that has the same effect as for standard py:function etc. directives: no index entries are generated for the documented object (and all autodocumented members). New in version 0.4. automodule also recognizes the synopsis, platform and deprecated options that the standard py:module directive supports. New in version 0.5. automodule and autoclass also has an member-order option that can be used to override the global value of autodoc_member_order for one directive. New in version 0.6. The directives supporting member documentation also have a exclude-members option that can be used to exclude single member names from documentation, if all members are to be documented. New in version 0.6. In an automodule directive with the members option set, only module members whose __module__ attribute is equal to the module name as given to automodule will be documented. This is to prevent documentation of imported classes or functions. Set the imported-members option if you want to prevent this behavior and document all available members. Note that attributes from imported modules will not be documented, because attribute documentation is discovered by parsing the source file of the current module. New in version 1.2. Add a list of modules in the autodoc_mock_imports to prevent import errors to halt the building process when some external dependencies are not importable at build time. New in version 1.3. As a hint to autodoc extension, you can put a :: separator in between module name and object name to let autodoc know the correct module name if it is ambiguous. .. autoclass:: module.name::Noodle autoclass also recognizes the class-doc-from option that can be used to override the global value of autoclass_content. New in version 4.1."
    },
    {
      "id": "directive-option-automodule-members",
      "title": ":members: (no value or comma separated list)",
      "content": "If set, autodoc will generate document for the members of the target module, class or exception. For example: .. automodule:: noodle :members: will document all module members (recursively), and .. autoclass:: Noodle :members: will document all class member methods and properties. By default, autodoc will not generate document for the members that are private, not having docstrings, inherited from super class, or special members. For modules, __all__ will be respected when looking for members unless you give the ignore-module-all flag option. Without ignore-module-all, the order of the members will also be the order in __all__. You can also give an explicit list of members; only these will then be documented: .. autoclass:: Noodle :members: eat, slurp"
    },
    {
      "id": "directive-option-automodule-undoc-members",
      "title": ":undoc-members: (no value)",
      "content": "If set, autodoc will also generate document for the members not having docstrings: .. automodule:: noodle :members: :undoc-members:"
    },
    {
      "id": "directive-option-automodule-private-members",
      "title": ":private-members: (no value or comma separated list)",
      "content": "If set, autodoc will also generate document for the private members (that is, those named like _private or __private): .. automodule:: noodle :members: :private-members: It can also take an explicit list of member names to be documented as arguments: .. automodule:: noodle :members: :private-members: _spicy, _garlickly New in version 1.1. Changed in version 3.2: The option can now take arguments."
    },
    {
      "id": "directive-option-automodule-special-members",
      "title": ":special-members: (no value or comma separated list)",
      "content": "If set, autodoc will also generate document for the special members (that is, those named like __special__): .. autoclass:: my.Class :members: :special-members: It can also take an explicit list of member names to be documented as arguments: .. autoclass:: my.Class :members: :special-members: __init__, __name__ New in version 1.1. Changed in version 1.2: The option can now take arguments"
    },
    {
      "id": "directive-autofunction",
      "title": ".. autofunction::",
      "content": "These work exactly like autoclass etc., but do not offer the options used for automatic member documentation. autodata and autoattribute support the annotation option. The option controls how the value of variable is shown. If specified without arguments, only the name of the variable will be printed, and its value is not shown: .. autodata:: CD_DRIVE :annotation: If the option specified with arguments, it is printed after the name as a value of the variable: .. autodata:: CD_DRIVE :annotation: = your CD device name By default, without annotation option, Sphinx tries to obtain the value of the variable and print it after the name. The no-value option can be used instead of a blank annotation to show the type hint but not the value: .. autodata:: CD_DRIVE :no-value: If both the annotation and no-value options are used, no-value has no effect. For module data members and class attributes, documentation can either be put into a comment with special formatting (using a #: to start the comment instead of just #), or in a docstring after the definition. Comments need to be either on a line of their own before the definition, or immediately after the assignment on the same line. The latter form is restricted to one line only. This means that in the following class definition, all attributes can be autodocumented: class Foo: \"\"\"Docstring for class Foo.\"\"\" #: Doc comment for class attribute Foo.bar. #: It can have multiple lines. bar = 1 flox = 1.5 #: Doc comment for Foo.flox. One line only. baz = 2 \"\"\"Docstring for class attribute Foo.baz.\"\"\" def __init__(self): #: Doc comment for instance attribute qux. self.qux = 3 self.spam = 4 \"\"\"Docstring for instance attribute spam.\"\"\" Changed in version 0.6: autodata and autoattribute can now extract docstrings. Changed in version 1.1: Comment docs are now allowed on the same line after an assignment. Changed in version 1.2: autodata and autoattribute have an annotation option. Changed in version 2.0: autodecorator added. Changed in version 2.1: autoproperty added. Changed in version 3.4: autodata and autoattribute now have a no-value option. Note If you document decorated functions or methods, keep in mind that autodoc retrieves its docstrings by importing the module and inspecting the __doc__ attribute of the given function or method. That means that if a decorator replaces the decorated function with another, it must copy the original __doc__ to the new function."
    },
    {
      "id": "directive-autodecorator",
      "title": ".. autodecorator::",
      "content": "These work exactly like autoclass etc., but do not offer the options used for automatic member documentation. autodata and autoattribute support the annotation option. The option controls how the value of variable is shown. If specified without arguments, only the name of the variable will be printed, and its value is not shown: .. autodata:: CD_DRIVE :annotation: If the option specified with arguments, it is printed after the name as a value of the variable: .. autodata:: CD_DRIVE :annotation: = your CD device name By default, without annotation option, Sphinx tries to obtain the value of the variable and print it after the name. The no-value option can be used instead of a blank annotation to show the type hint but not the value: .. autodata:: CD_DRIVE :no-value: If both the annotation and no-value options are used, no-value has no effect. For module data members and class attributes, documentation can either be put into a comment with special formatting (using a #: to start the comment instead of just #), or in a docstring after the definition. Comments need to be either on a line of their own before the definition, or immediately after the assignment on the same line. The latter form is restricted to one line only. This means that in the following class definition, all attributes can be autodocumented: class Foo: \"\"\"Docstring for class Foo.\"\"\" #: Doc comment for class attribute Foo.bar. #: It can have multiple lines. bar = 1 flox = 1.5 #: Doc comment for Foo.flox. One line only. baz = 2 \"\"\"Docstring for class attribute Foo.baz.\"\"\" def __init__(self): #: Doc comment for instance attribute qux. self.qux = 3 self.spam = 4 \"\"\"Docstring for instance attribute spam.\"\"\" Changed in version 0.6: autodata and autoattribute can now extract docstrings. Changed in version 1.1: Comment docs are now allowed on the same line after an assignment. Changed in version 1.2: autodata and autoattribute have an annotation option. Changed in version 2.0: autodecorator added. Changed in version 2.1: autoproperty added. Changed in version 3.4: autodata and autoattribute now have a no-value option. Note If you document decorated functions or methods, keep in mind that autodoc retrieves its docstrings by importing the module and inspecting the __doc__ attribute of the given function or method. That means that if a decorator replaces the decorated function with another, it must copy the original __doc__ to the new function."
    },
    {
      "id": "directive-autodata",
      "title": ".. autodata::",
      "content": "These work exactly like autoclass etc., but do not offer the options used for automatic member documentation. autodata and autoattribute support the annotation option. The option controls how the value of variable is shown. If specified without arguments, only the name of the variable will be printed, and its value is not shown: .. autodata:: CD_DRIVE :annotation: If the option specified with arguments, it is printed after the name as a value of the variable: .. autodata:: CD_DRIVE :annotation: = your CD device name By default, without annotation option, Sphinx tries to obtain the value of the variable and print it after the name. The no-value option can be used instead of a blank annotation to show the type hint but not the value: .. autodata:: CD_DRIVE :no-value: If both the annotation and no-value options are used, no-value has no effect. For module data members and class attributes, documentation can either be put into a comment with special formatting (using a #: to start the comment instead of just #), or in a docstring after the definition. Comments need to be either on a line of their own before the definition, or immediately after the assignment on the same line. The latter form is restricted to one line only. This means that in the following class definition, all attributes can be autodocumented: class Foo: \"\"\"Docstring for class Foo.\"\"\" #: Doc comment for class attribute Foo.bar. #: It can have multiple lines. bar = 1 flox = 1.5 #: Doc comment for Foo.flox. One line only. baz = 2 \"\"\"Docstring for class attribute Foo.baz.\"\"\" def __init__(self): #: Doc comment for instance attribute qux. self.qux = 3 self.spam = 4 \"\"\"Docstring for instance attribute spam.\"\"\" Changed in version 0.6: autodata and autoattribute can now extract docstrings. Changed in version 1.1: Comment docs are now allowed on the same line after an assignment. Changed in version 1.2: autodata and autoattribute have an annotation option. Changed in version 2.0: autodecorator added. Changed in version 2.1: autoproperty added. Changed in version 3.4: autodata and autoattribute now have a no-value option. Note If you document decorated functions or methods, keep in mind that autodoc retrieves its docstrings by importing the module and inspecting the __doc__ attribute of the given function or method. That means that if a decorator replaces the decorated function with another, it must copy the original __doc__ to the new function."
    },
    {
      "id": "directive-automethod",
      "title": ".. automethod::",
      "content": "These work exactly like autoclass etc., but do not offer the options used for automatic member documentation. autodata and autoattribute support the annotation option. The option controls how the value of variable is shown. If specified without arguments, only the name of the variable will be printed, and its value is not shown: .. autodata:: CD_DRIVE :annotation: If the option specified with arguments, it is printed after the name as a value of the variable: .. autodata:: CD_DRIVE :annotation: = your CD device name By default, without annotation option, Sphinx tries to obtain the value of the variable and print it after the name. The no-value option can be used instead of a blank annotation to show the type hint but not the value: .. autodata:: CD_DRIVE :no-value: If both the annotation and no-value options are used, no-value has no effect. For module data members and class attributes, documentation can either be put into a comment with special formatting (using a #: to start the comment instead of just #), or in a docstring after the definition. Comments need to be either on a line of their own before the definition, or immediately after the assignment on the same line. The latter form is restricted to one line only. This means that in the following class definition, all attributes can be autodocumented: class Foo: \"\"\"Docstring for class Foo.\"\"\" #: Doc comment for class attribute Foo.bar. #: It can have multiple lines. bar = 1 flox = 1.5 #: Doc comment for Foo.flox. One line only. baz = 2 \"\"\"Docstring for class attribute Foo.baz.\"\"\" def __init__(self): #: Doc comment for instance attribute qux. self.qux = 3 self.spam = 4 \"\"\"Docstring for instance attribute spam.\"\"\" Changed in version 0.6: autodata and autoattribute can now extract docstrings. Changed in version 1.1: Comment docs are now allowed on the same line after an assignment. Changed in version 1.2: autodata and autoattribute have an annotation option. Changed in version 2.0: autodecorator added. Changed in version 2.1: autoproperty added. Changed in version 3.4: autodata and autoattribute now have a no-value option. Note If you document decorated functions or methods, keep in mind that autodoc retrieves its docstrings by importing the module and inspecting the __doc__ attribute of the given function or method. That means that if a decorator replaces the decorated function with another, it must copy the original __doc__ to the new function."
    },
    {
      "id": "directive-autoattribute",
      "title": ".. autoattribute::",
      "content": "These work exactly like autoclass etc., but do not offer the options used for automatic member documentation. autodata and autoattribute support the annotation option. The option controls how the value of variable is shown. If specified without arguments, only the name of the variable will be printed, and its value is not shown: .. autodata:: CD_DRIVE :annotation: If the option specified with arguments, it is printed after the name as a value of the variable: .. autodata:: CD_DRIVE :annotation: = your CD device name By default, without annotation option, Sphinx tries to obtain the value of the variable and print it after the name. The no-value option can be used instead of a blank annotation to show the type hint but not the value: .. autodata:: CD_DRIVE :no-value: If both the annotation and no-value options are used, no-value has no effect. For module data members and class attributes, documentation can either be put into a comment with special formatting (using a #: to start the comment instead of just #), or in a docstring after the definition. Comments need to be either on a line of their own before the definition, or immediately after the assignment on the same line. The latter form is restricted to one line only. This means that in the following class definition, all attributes can be autodocumented: class Foo: \"\"\"Docstring for class Foo.\"\"\" #: Doc comment for class attribute Foo.bar. #: It can have multiple lines. bar = 1 flox = 1.5 #: Doc comment for Foo.flox. One line only. baz = 2 \"\"\"Docstring for class attribute Foo.baz.\"\"\" def __init__(self): #: Doc comment for instance attribute qux. self.qux = 3 self.spam = 4 \"\"\"Docstring for instance attribute spam.\"\"\" Changed in version 0.6: autodata and autoattribute can now extract docstrings. Changed in version 1.1: Comment docs are now allowed on the same line after an assignment. Changed in version 1.2: autodata and autoattribute have an annotation option. Changed in version 2.0: autodecorator added. Changed in version 2.1: autoproperty added. Changed in version 3.4: autodata and autoattribute now have a no-value option. Note If you document decorated functions or methods, keep in mind that autodoc retrieves its docstrings by importing the module and inspecting the __doc__ attribute of the given function or method. That means that if a decorator replaces the decorated function with another, it must copy the original __doc__ to the new function."
    },
    {
      "id": "directive-autoproperty",
      "title": ".. autoproperty::",
      "content": "These work exactly like autoclass etc., but do not offer the options used for automatic member documentation. autodata and autoattribute support the annotation option. The option controls how the value of variable is shown. If specified without arguments, only the name of the variable will be printed, and its value is not shown: .. autodata:: CD_DRIVE :annotation: If the option specified with arguments, it is printed after the name as a value of the variable: .. autodata:: CD_DRIVE :annotation: = your CD device name By default, without annotation option, Sphinx tries to obtain the value of the variable and print it after the name. The no-value option can be used instead of a blank annotation to show the type hint but not the value: .. autodata:: CD_DRIVE :no-value: If both the annotation and no-value options are used, no-value has no effect. For module data members and class attributes, documentation can either be put into a comment with special formatting (using a #: to start the comment instead of just #), or in a docstring after the definition. Comments need to be either on a line of their own before the definition, or immediately after the assignment on the same line. The latter form is restricted to one line only. This means that in the following class definition, all attributes can be autodocumented: class Foo: \"\"\"Docstring for class Foo.\"\"\" #: Doc comment for class attribute Foo.bar. #: It can have multiple lines. bar = 1 flox = 1.5 #: Doc comment for Foo.flox. One line only. baz = 2 \"\"\"Docstring for class attribute Foo.baz.\"\"\" def __init__(self): #: Doc comment for instance attribute qux. self.qux = 3 self.spam = 4 \"\"\"Docstring for instance attribute spam.\"\"\" Changed in version 0.6: autodata and autoattribute can now extract docstrings. Changed in version 1.1: Comment docs are now allowed on the same line after an assignment. Changed in version 1.2: autodata and autoattribute have an annotation option. Changed in version 2.0: autodecorator added. Changed in version 2.1: autoproperty added. Changed in version 3.4: autodata and autoattribute now have a no-value option. Note If you document decorated functions or methods, keep in mind that autodoc retrieves its docstrings by importing the module and inspecting the __doc__ attribute of the given function or method. That means that if a decorator replaces the decorated function with another, it must copy the original __doc__ to the new function."
    },
    {
      "id": "confval-autoclass_content",
      "title": "autoclass_content",
      "content": "This value selects what content will be inserted into the main body of an autoclass directive. The possible values are: \"class\"Only the class\u2019 docstring is inserted. This is the default. You can still document __init__ as a separate method using automethod or the members option to autoclass. \"both\"Both the class\u2019 and the __init__ method\u2019s docstring are concatenated and inserted. \"init\"Only the __init__ method\u2019s docstring is inserted. New in version 0.3. If the class has no __init__ method or if the __init__ method\u2019s docstring is empty, but the class has a __new__ method\u2019s docstring, it is used instead. New in version 1.4."
    },
    {
      "id": "confval-autodoc_class_signature",
      "title": "autodoc_class_signature",
      "content": "This value selects how the signature will be displayed for the class defined by autoclass directive. The possible values are: \"mixed\"Display the signature with the class name. \"separated\"Display the signature as a method. The default is \"mixed\". New in version 4.1."
    },
    {
      "id": "confval-autodoc_member_order",
      "title": "autodoc_member_order",
      "content": "This value selects if automatically documented members are sorted alphabetical (value 'alphabetical'), by member type (value 'groupwise') or by source order (value 'bysource'). The default is alphabetical. Note that for source order, the module must be a Python module with the source code available. New in version 0.6. Changed in version 1.0: Support for 'bysource'."
    },
    {
      "id": "confval-autodoc_default_flags",
      "title": "autodoc_default_flags",
      "content": "This value is a list of autodoc directive flags that should be automatically applied to all autodoc directives. The supported flags are 'members', 'undoc-members', 'private-members', 'special-members', 'inherited-members', 'show-inheritance', 'ignore-module-all' and 'exclude-members'. New in version 1.0. Deprecated since version 1.8: Integrated into autodoc_default_options."
    },
    {
      "id": "confval-autodoc_default_options",
      "title": "autodoc_default_options",
      "content": "The default options for autodoc directives. They are applied to all autodoc directives automatically. It must be a dictionary which maps option names to the values. For example: autodoc_default_options = { 'members': 'var1, var2', 'member-order': 'bysource', 'special-members': '__init__', 'undoc-members': True, 'exclude-members': '__weakref__' } Setting None or True to the value is equivalent to giving only the option name to the directives. The supported options are 'members', 'member-order', 'undoc-members', 'private-members', 'special-members', 'inherited-members', 'show-inheritance', 'ignore-module-all', 'imported-members', 'exclude-members', 'class-doc-from' and 'no-value'. New in version 1.8. Changed in version 2.0: Accepts True as a value. Changed in version 2.1: Added 'imported-members'. Changed in version 4.1: Added 'class-doc-from'. Changed in version 4.5: Added 'no-value'."
    },
    {
      "id": "confval-autodoc_docstring_signature",
      "title": "autodoc_docstring_signature",
      "content": "Functions imported from C modules cannot be introspected, and therefore the signature for such functions cannot be automatically determined. However, it is an often-used convention to put the signature into the first line of the function\u2019s docstring. If this boolean value is set to True (which is the default), autodoc will look at the first line of the docstring for functions and methods, and if it looks like a signature, use the line as the signature and remove it from the docstring content. autodoc will continue to look for multiple signature lines, stopping at the first line that does not look like a signature. This is useful for declaring overloaded function signatures. New in version 1.1. Changed in version 3.1: Support overloaded signatures Changed in version 4.0: Overloaded signatures do not need to be separated by a backslash"
    },
    {
      "id": "confval-autodoc_mock_imports",
      "title": "autodoc_mock_imports",
      "content": "This value contains a list of modules to be mocked up. This is useful when some external dependencies are not met at build time and break the building process. You may only specify the root package of the dependencies themselves and omit the sub-modules: autodoc_mock_imports = [\"django\"] Will mock all imports under the django package. New in version 1.3. Changed in version 1.6: This config value only requires to declare the top-level modules that should be mocked."
    },
    {
      "id": "confval-autodoc_typehints",
      "title": "autodoc_typehints",
      "content": "This value controls how to represent typehints. The setting takes the following values: 'signature' \u2013 Show typehints in the signature (default) 'description' \u2013 Show typehints as content of the function or method The typehints of overloaded functions or methods will still be represented in the signature. 'none' \u2013 Do not show typehints 'both' \u2013 Show typehints in the signature and as content of the function or method Overloaded functions or methods will not have typehints included in the description because it is impossible to accurately represent all possible overloads as a list of parameters. New in version 2.1. New in version 3.0: New option 'description' is added. New in version 4.1: New option 'both' is added."
    },
    {
      "id": "confval-autodoc_typehints_description_target",
      "title": "autodoc_typehints_description_target",
      "content": "This value controls whether the types of undocumented parameters and return values are documented when autodoc_typehints is set to description. The default value is \"all\", meaning that types are documented for all parameters and return values, whether they are documented or not. When set to \"documented\", types will only be documented for a parameter or a return value that is already documented by the docstring. With \"documented_params\", parameter types will only be annotated if the parameter is documented in the docstring. The return type is always annotated (except if it is None). New in version 4.0. New in version 5.0: New option 'documented_params' is added."
    },
    {
      "id": "confval-autodoc_type_aliases",
      "title": "autodoc_type_aliases",
      "content": "A dictionary for users defined type aliases that maps a type name to the full-qualified object name. It is used to keep type aliases not evaluated in the document. Defaults to empty ({}). The type aliases are only available if your program enables Postponed Evaluation of Annotations (PEP 563) feature via from __future__ import annotations. For example, there is code using a type alias: from __future__ import annotations AliasType = Union[List[Dict[Tuple[int, str], Set[int]]], Tuple[str, List[str]]] def f() -> AliasType: ... If autodoc_type_aliases is not set, autodoc will generate internal mark-up from this code as following: .. py:function:: f() -> Union[List[Dict[Tuple[int, str], Set[int]]], Tuple[str, List[str]]] ... If you set autodoc_type_aliases as {'AliasType': 'your.module.AliasType'}, it generates the following document internally: .. py:function:: f() -> your.module.AliasType: ... New in version 3.3."
    },
    {
      "id": "confval-autodoc_typehints_format",
      "title": "autodoc_typehints_format",
      "content": "This value controls the format of typehints. The setting takes the following values: 'fully-qualified' \u2013 Show the module name and its name of typehints 'short' \u2013 Suppress the leading module names of the typehints (ex. io.StringIO -> StringIO) (default) New in version 4.4. Changed in version 5.0: The default setting was changed to 'short'"
    },
    {
      "id": "confval-autodoc_preserve_defaults",
      "title": "autodoc_preserve_defaults",
      "content": "If True, the default argument values of functions will be not evaluated on generating document. It preserves them as is in the source code. New in version 4.0: Added as an experimental feature. This will be integrated into autodoc core in the future."
    },
    {
      "id": "confval-autodoc_warningiserror",
      "title": "autodoc_warningiserror",
      "content": "This value controls the behavior of sphinx-build -W during importing modules. If False is given, autodoc forcedly suppresses the error if the imported module emits warnings. By default, True."
    },
    {
      "id": "confval-autodoc_inherit_docstrings",
      "title": "autodoc_inherit_docstrings",
      "content": "This value controls the docstrings inheritance. If set to True the docstring for classes or methods, if not explicitly set, is inherited from parents. The default is True. New in version 1.7."
    },
    {
      "id": "event-autodoc-process-docstring",
      "title": "autodoc-process-docstring(app, what, name, obj, options, lines)",
      "content": "New in version 0.4. Emitted when autodoc has read and processed a docstring. lines is a list of strings \u2013 the lines of the processed docstring \u2013 that the event handler can modify in place to change what Sphinx puts into the output. Parameters: app \u2013 the Sphinx application object what \u2013 the type of the object which the docstring belongs to (one of \"module\", \"class\", \"exception\", \"function\", \"method\", \"attribute\") name \u2013 the fully qualified name of the object obj \u2013 the object itself options \u2013 the options given to the directive: an object with attributes inherited_members, undoc_members, show_inheritance and noindex that are true if the flag option of same name was given to the auto directive lines \u2013 the lines of the docstring, see above"
    },
    {
      "id": "event-autodoc-before-process-signature",
      "title": "autodoc-before-process-signature(app, obj, bound_method)",
      "content": "New in version 2.4. Emitted before autodoc formats a signature for an object. The event handler can modify an object to change its signature. Parameters: app \u2013 the Sphinx application object obj \u2013 the object itself bound_method \u2013 a boolean indicates an object is bound method or not"
    },
    {
      "id": "event-autodoc-process-signature",
      "title": "autodoc-process-signature(app, what, name, obj, options, signature, return_annotation)",
      "content": "New in version 0.5. Emitted when autodoc has formatted a signature for an object. The event handler can return a new tuple (signature, return_annotation) to change what Sphinx puts into the output. Parameters: app \u2013 the Sphinx application object what \u2013 the type of the object which the docstring belongs to (one of \"module\", \"class\", \"exception\", \"function\", \"method\", \"attribute\") name \u2013 the fully qualified name of the object obj \u2013 the object itself options \u2013 the options given to the directive: an object with attributes inherited_members, undoc_members, show_inheritance and noindex that are true if the flag option of same name was given to the auto directive signature \u2013 function signature, as a string of the form \"(parameter_1, parameter_2)\", or None if introspection didn\u2019t succeed and signature wasn\u2019t specified in the directive. return_annotation \u2013 function return annotation as a string of the form \" -> annotation\", or None if there is no return annotation"
    },
    {
      "id": "sphinx.ext.autodoc.cut_lines",
      "title": "sphinx.ext.autodoc.cut_lines(pre: int, post: int = 0, what: str | None = None) \u2192 Callable[source]",
      "content": "Return a listener that removes the first pre and last post lines of every docstring. If what is a sequence of strings, only docstrings of a type in what will be processed. Use like this (e.g. in the setup() function of conf.py): from sphinx.ext.autodoc import cut_lines app.connect('autodoc-process-docstring', cut_lines(4, what=['module'])) This can (and should) be used in place of automodule_skip_lines."
    },
    {
      "id": "sphinx.ext.autodoc.between",
      "title": "sphinx.ext.autodoc.between(marker: str, what: Sequence[str] | None = None, keepempty: bool = False, exclude: bool = False) \u2192 Callable[source]",
      "content": "Return a listener that either keeps, or if exclude is True excludes, lines between lines that match the marker regular expression. If no line matches, the resulting docstring would be empty, so no change will be made unless keepempty is true. If what is a sequence of strings, only docstrings of a type in what will be processed."
    },
    {
      "id": "event-autodoc-process-bases",
      "title": "autodoc-process-bases(app, name, obj, options, bases)",
      "content": "Emitted when autodoc has read and processed a class to determine the base-classes. bases is a list of classes that the event handler can modify in place to change what Sphinx puts into the output. It\u2019s emitted only if show-inheritance option given. Parameters: app \u2013 the Sphinx application object name \u2013 the fully qualified name of the object obj \u2013 the object itself options \u2013 the options given to the class directive bases \u2013 the list of base classes signature. see above. New in version 4.1. Changed in version 4.3: bases can contain a string as a base class name. It will be processed as reST mark-up\u2019ed text."
    },
    {
      "id": "event-autodoc-skip-member",
      "title": "autodoc-skip-member(app, what, name, obj, skip, options)",
      "content": "New in version 0.5. Emitted when autodoc has to decide whether a member should be included in the documentation. The member is excluded if a handler returns True. It is included if the handler returns False. If more than one enabled extension handles the autodoc-skip-member event, autodoc will use the first non-None value returned by a handler. Handlers should return None to fall back to the skipping behavior of autodoc and other enabled extensions. Parameters: app \u2013 the Sphinx application object what \u2013 the type of the object which the docstring belongs to (one of \"module\", \"class\", \"exception\", \"function\", \"method\", \"attribute\") name \u2013 the fully qualified name of the object obj \u2013 the object itself skip \u2013 a boolean indicating if autodoc will skip this member if the user handler does not override the decision options \u2013 the options given to the directive: an object with attributes inherited_members, undoc_members, show_inheritance and noindex that are true if the flag option of same name was given to the auto directive"
    },
    {
      "id": "module-sphinx.ext.autodoc",
      "title": "sphinx.ext.autodoc \u2013 Include documentation from docstrings",
      "content": "This extension can import the modules you are documenting, and pull in documentation from docstrings in a semi-automatic way. Note For Sphinx (actually, the Python interpreter that executes Sphinx) to find your module, it must be importable. That means that the module or the package must be in one of the directories on sys.path \u2013 adapt your sys.path in the configuration file accordingly. Warning autodoc imports the modules to be documented. If any modules have side effects on import, these will be executed by autodoc when sphinx-build is run. If you document scripts (as opposed to library modules), make sure their main routine is protected by a if __name__ == '__main__' condition. For this to work, the docstrings must of course be written in correct reStructuredText. You can then use all of the usual Sphinx markup in the docstrings, and it will end up correctly in the documentation. Together with hand-written documentation, this technique eases the pain of having to maintain two locations for documentation, while at the same time avoiding auto-generated-looking pure API documentation. If you prefer NumPy or Google style docstrings over reStructuredText, you can also enable the napoleon extension. napoleon is a preprocessor that converts your docstrings to correct reStructuredText before autodoc processes them."
    },
    {
      "id": "directives",
      "title": "Directives",
      "content": "autodoc provides several directives that are versions of the usual py:module, py:class and so forth. On parsing time, they import the corresponding module and extract the docstring of the given objects, inserting them into the page source under a suitable py:module, py:class etc. directive. Note Just as py:class respects the current py:module, autoclass will also do so. Likewise, automethod will respect the current py:class."
    },
    {
      "id": "configuration",
      "title": "Configuration",
      "content": "There are also config values that you can set: suppress_warnings autodoc supports to suppress warning messages via suppress_warnings. It allows following warnings types in addition: autodoc autodoc.import_object"
    },
    {
      "id": "docstring-preprocessing",
      "title": "Docstring preprocessing",
      "content": "autodoc provides the following additional events: The sphinx.ext.autodoc module provides factory functions for commonly needed docstring processing in event autodoc-process-docstring:"
    },
    {
      "id": "skipping-members",
      "title": "Skipping members",
      "content": "autodoc allows the user to define a custom method for determining whether a member should be included in the documentation by using the following event:"
    }
  ]
}
